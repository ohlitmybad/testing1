<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="https://datamb.football/favicon.ico">
    <meta name="description" content="Plot Top 7 League team statistics. Visualize team performance and analyze multiple metrics such as Goals, Goals conceded, xG, Shots on target, Pressing, Defensive duels, Pass completion and more for teams in Premier League, La Liga, Bundesliga, Serie A, Ligue 1, Eredivisie, Primeira Liga.">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@DataMB_">
    <meta name="twitter:title" content="DataMB | Plot Teams">
    <meta name="twitter:description" content="Generate scatter plots for Top 7 League teams">
    <meta name="twitter:image" content="https://datamb.football/vignettes/teamplots.png">
    <meta property="og:image" content="https://datamb.football/vignettes/teamplots.png">
    <title translate="no">DataMB | Plot Teams</title>
    
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <link rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --background-color: #f5f7fa;
            --container-bg: #ffffff;
            --text-color: #333333;
            --border-color: #e0e0e0;
            --hover-color: #f0f0f0;
            --button-color: #3498db;
            --button-text: #ffffff;
            --header-bg: #ffffff;
            --shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .dark-mode {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --background-color: #1a1a1a;
            --container-bg: #2c2c2c;
            --text-color: #f5f5f5;
            --border-color: #444444;
            --hover-color: #3a3a3a;
            --button-color: #3498db;
            --button-text: #ffffff;
            --header-bg: #2c2c2c;
            --shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
        }

        .header {
            background-color: var(--header-bg);
            display: flex;
            padding: 20px;
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow);
            position: relative;
            font-family: system-ui;
            top: 0;
            z-index: 100;
        }


        .container {
            max-width: 1200px;
            margin: 30px auto;
            padding: 0 20px;
        }

        .plot-container {
            background-color: var(--container-bg);
            border-radius: 10px;
            box-shadow: var(--shadow);
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid var(--border-color);
            width: 100%;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 12px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        select, input {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--container-bg);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background-color: var(--button-color);
            color: var(--button-text);
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #2980b9;
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        .btn-outline:hover {
            background-color: var(--hover-color);
        }

        .btn-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            padding: 0;
            border-radius: 6px;
        }

        #search-bar {
            width: 150px;
        }

        #select-x, #select-y {
            width: 180px;
        }

        .select-all-button, 
        button[onclick="takeScreenshot()"] {
            width: 100px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px 0;
        }

        .position-filters {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .position-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background-color: var(--container-bg);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .position-btn:hover, .position-btn.active {
            background-color: var(--primary-color);
            color: white;
        }

        #scatter-plot {
            width: 100%;
            height: 764px;
            display: block;
            margin: 0 auto;
            max-width: 1040px;
        }

        .chart-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tooltip {
            position: absolute;
            background-color: var(--container-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: var(--shadow);
            z-index: 1000;
        }

        .player-name {
            font-size: 12px;
            font-weight: 500;
        }

        circle {
            cursor: pointer;
            transition: r 0.2s, fill 0.2s;
        }

        circle.highlighted {
            stroke: #ff00ff;
            stroke-width: 3px;
        }

        /* Add new styles for better search highlighting */
        circle.search-match {
            fill: #ff3366 !important; /* Bright pink fill */
            stroke: #ffffff;
            stroke-width: 2px;
            filter: drop-shadow(0 0 5px rgba(255, 51, 102, 0.7));
            animation: circlePulse 1.5s infinite ease-in-out;
        }

        .dark-mode circle.search-match {
            stroke: #000000;
        }

        @keyframes circlePulse {
            0% { r: 6; }
            50% { r: 9; }
            100% { r: 6; }
        }

        .team-label.search-match {
            font-weight: 700 !important;
            fill: #ff3366 !important;
            filter: drop-shadow(0 0 2px rgba(255, 255, 255, 1));
            opacity: 1 !important;
            animation: labelPulse 1.5s infinite ease-in-out;
        }

        @keyframes labelPulse {
            0% { font-size: 12px; }
            50% { font-size: 14px; }
            100% { font-size: 12px; }
        }

        .dark-mode .team-label.search-match {
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 1));
        }

        .team-label.search-dimmed {
            opacity: 0 !important;
        }

        .team-label {
            pointer-events: none;
            text-shadow: 0px 0px 2px white, 0px 0px 2px white, 0px 0px 2px white, 0px 0px 2px white;
        }

        .dark-mode .team-label {
            fill: #f5f5f5 !important;
            text-shadow: 0px 0px 2px #1a1a1a, 0px 0px 2px #1a1a1a, 0px 0px 2px #1a1a1a, 0px 0px 2px #1a1a1a;
        }

        .dark-mode-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--container-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow);
            z-index: 100;
            transition: background-color 0.3s;
        }

        .toggle-icon::before {
            font-family: "Ionicons";
            content: "\f467";
            font-size: 20px;
            color: var(--text-color);
        }

        .dark-mode .toggle-icon::before {
            content: "\f3b0";
        }

        .search-input-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        .search-input-container {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            width: 400px;
        }

        #searchInput {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            font-size: 16px;
            outline: none;
            margin-bottom: 10px;
        }

        #autocompleteBox {
            max-height: 200px;
            overflow-y: auto;
            background-color: var(--container-bg);
        }

        #autocompleteBox div {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        #autocompleteBox div:hover {
            background-color: var(--hover-color);
        }

        #autocompleteBox a {
            text-decoration: none;
            color: var(--text-color);
            display: block;
        }

        @media (max-width: 768px) {
            .header {
                padding: 15px;
                flex-wrap: wrap;
            }
            
            .navigation {
                gap: 15px;
                margin-top: 10px;
            }
            
            .plot-container {
                padding: 15px;
            }
            
            .controls {
                flex-direction: column;
            }
            
            #scatter-plot {
                height: 400px;
            }
        }

        /* Styles for the diagonal reference line */
        .dark-mode .xy-line {
            stroke: #3cb371; /* Slightly different green for dark mode */
        }


  
  .search-input-modal {
      display: none;
      position: fixed; 
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7); 
      z-index: 999; 
  }
  
  .search-input-container {
      position: absolute;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #fff;
      padding: 20px;
      border-radius: 4px;
      z-index: 1000; 
  }
  
  #searchInput3 {
              width: 340px;
              padding: 12px;
              border: 3px solid #ccc;
              border-radius: 4px;
              font-size: 19px;
              outline: none;
          }
  
          #autocompleteBox {
              width: 360px;
              max-height: 150px;
              overflow-y: auto;
              background-color: #fff;
          }
  
  
          #autocompleteBox ul {
              list-style: none;
              padding: 0;
              margin: 0;
          }
  
          #autocompleteBox li {
              margin: 0;
              padding: 5px;
          }
  
          #autocompleteBox {
              line-height: 2; 
              text-align: center !important;
  
          }
  
          #autocompleteBox a {
              text-decoration: none;
              font-family: Arial, sans-serif;
              text-align: center !important;
              color: #333 !important;
              cursor: pointer; 
          }
  
          #autocompleteBox li:hover {
              background-color: #f0f0f0;
          }
          #searchButton3 {
            padding: 8.5px;  /* Reduced from 10px */
  background-color: #0074d9;
  color: #fff;
  border: none;
  width: 34px;  /* Reduced from 40px */
  height: 34px;  /* Reduced from 40px */
  border-radius: 50%;
  cursor: pointer;
  font-size: 17px;  /* Reduced from 20px */
  }


  body.dark-mode .header .button10 {
      color: #aeaeae;
}
body.dark-mode .header .button10:hover {
  color: #2563eb;
background-color: #ffffff;
}

    body.dark-mode header a {
      color: #aeaeae;
}

body.dark-mode .header .logo img {
  opacity: 0.88;
}


body.dark-mode .language-button {
      background-color: #0F0F0E;
      color: #aeaeae;
}

body.dark-mode .language-button:hover {
      background-color: #0F0F0E;
      color: #aeaeae;
}


body.dark-mode .language-dropdown {

  background: #e8e6e6;

}

body.dark-mode .language-option {

  color: #000000;
}



  

.header .logo {
  display: flex;
  align-items: center;
  margin-right: auto; /* Push logo to the left */
}

.header .logo img {
  height: 34px;
  width: auto;
  opacity: 0.84;
}
.header .logo-text {
  margin-left: 10px;
  font-size: 23px;
  font-weight: 600;
}

.header .navigation {
  display: flex;
  align-items: center;
  gap: 25px; /* Reduced gap between buttons */
  position: absolute;
  left: 50%;
  transform: translateX(-50%); /* Center the navigation */
}



.header .button10 {
  padding: 0.5rem 1rem;
  text-decoration: none;
  color: #333;
  line-height: 1.6;
  border-radius: 4px;
  transition: background-color 0.2s;
  font-size: 1.1rem;  /* Added larger font size */
}


.header .button10:hover {
  background-color: #f0f0f0;
  color: #2563eb;

}



/* Group search and language buttons */
.header-right {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-left: auto; /* Push buttons to the right */
}

header a {
      color: black;
      text-decoration: none;
    }

    .language-switcher-container {
  position: relative;
  display: none;
}

.language-button {
  background: none;
  border: none;
  cursor: pointer;
  padding: 10px;
  color: #444444;
  display: flex;
  align-items: center;
  font-size: 17px;
}

.language-button iconify-icon {
  font-size: 24px;
  opacity: 0.7;
}

.language-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  padding: 10px;
  width: 200px;
  z-index: 1000;
}

.language-option {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  cursor: pointer;
  border-radius: 4px;
  color: #444444;
  text-decoration: none;
}



.language-option iconify-icon {
  margin-right: 10px;
  font-size: 20px;
}

.language-dropdown.show {
  display: block;
}
    </style>
</head>
<body>
  <header class="header">
    <div class="logo">
      <a href="https://datamb.football">
        <img src="https://datamb.football/logo.png" alt="Football team statistics comparison. Radar comparison tool. Visualise and compare team data from the top 7 leagues : Premier League, La Liga, Bundesliga, Serie A, Ligue 1, Eredivisie, Primeira Liga" /></a>
        <div class="logo-text"><a href="https://datamb.football">&nbsp;Teams</a></div>
    </div>
    <nav class="navigation">
      <a href="https://datamb.football/teams" class="button10" data-i18n="header.home">Home</a>
      <a href="https://datamb.football/join" class="button10" data-i18n="header.pro">Pro</a>
      <a href="https://datamb.football/guide" class="button10" data-i18n="header.guide">Guide</a>
    </nav>
    <div class="header-right">
    <div class="search-container">
      <button id="searchButton3"><iconify-icon icon="ion:search-outline"></iconify-icon></button>
  </div>
    <div class="language-switcher-container">
      <button class="language-button" id="languageButton">
        <iconify-icon icon="heroicons:globe-alt"></iconify-icon>
      </button>
      <div class="language-dropdown" id="languageDropdown">
        <a href="?lang=en" class="language-option"><iconify-icon icon="flag:gb-4x3"></iconify-icon>English</a>
      </div>
    </div></div>
  </header>
    <div class="container">
        <div class="plot-container">
            <div class="controls">


              <div class="control-group">
                <select id="select-x"></select>
                <select id="select-y"></select>
                </div>
                <div class="control-group">
                    <select id="select-league" onchange="updateChart()">
                        <option value="all">🇪🇺 Top 7 Leagues</option>
                        <option value="Top 5 Leagues">🇪🇺 Top 5 Leagues</option>
                        <option value="Premier League">🏴󠁧󠁢󠁥󠁮󠁧󠁿 Premier League</option>
                        <option value="La Liga">🇪🇸 La Liga</option>
                        <option value="Bundesliga">🇩🇪 Bundesliga</option>
                        <option value="Serie A">🇮🇹 Serie A</option> 
                        <option value="Ligue 1">🇫🇷 Ligue 1</option>
                        <option value="Eredivisie">🇳🇱 Eredivisie</option>
                        <option value="Primeira Liga">🇵🇹 Liga Portugal</option>
                    </select>
                </div>
                <div class="control-group">
                  <input type="text" id="search-bar" placeholder="Search team...">
                  <button id="toggle-median-lines" class="btn btn-outline btn-icon">
                    <div class="icon">
                        <i class="ion-stats-bars" style="font-size: 18px;"></i>
                    </div>
                </button>
              </div>
      
                    <div class="control-group">
                      <button class="btn btn-outline select-all-button" onclick="selectAllCircles()">Click All</button>
                      <button class="btn btn-outline select-all-button" onclick="takeScreenshot()">Screenshot</button>
                    </div>
                </div>
       
            <div class="chart-container">
              <svg id="scatter-plot"></svg>
            </div>
            
            <div class="legend" id="league-legend">
              <!-- Legend items will be added here dynamically -->
            </div>
        </div>
    </div>

    <div class="dark-mode-toggle" onclick="toggleDarkMode()">
        <div class="toggle-icon"></div>
    </div>

    <div class="search-input-modal" id="searchInputModal">
        <div class="search-input-container">
            <input type="text" id="searchInput" placeholder="Enter a team or player name...">
            <div id="autocompleteBox"></div>
        </div>
    </div>

    <script>
        // ... existing scripts ...
        
        // Function to toggle dark mode
        function toggleDarkMode() {
            const body = document.querySelector("body");
            body.classList.toggle("dark-mode");
            
            // Store the user's preference in local storage
            const isDarkMode = body.classList.contains("dark-mode");
            localStorage.setItem("darkMode", isDarkMode);
        }
        
        // Check if user has a stored preference for dark mode
        const storedDarkMode = localStorage.getItem("darkMode");
        
        if (storedDarkMode === "true") {
            const body = document.querySelector("body");
            body.classList.add("dark-mode");
        }
        
        // Function to capture and download the chart area
        function takeScreenshot() {
            // Get the SVG element
            const svg = document.getElementById('scatter-plot');
            
            // Create a canvas element
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match SVG
            const svgRect = svg.getBoundingClientRect();
            canvas.width = svgRect.width;
            canvas.height = svgRect.height;
            
            // Fill canvas with a white background
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Create an image from the SVG
            const img = new Image();
            const svgData = new XMLSerializer().serializeToString(svg);
            
            // Properly encode the SVG data
            const encodedData = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
            img.src = encodedData;
            
            img.onload = function() {
                // Draw the image on the canvas
                ctx.drawImage(img, 0, 0);
                
                // Convert canvas to image and trigger download
                const dataURL = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'chart-screenshot.png';
                link.href = dataURL;
                link.click();
            };
        }
        
        // Add event listeners for position buttons
        document.querySelectorAll('.position-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.position-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                // Add position filtering logic here
            });
        });
        
        // Search modal functionality
        const searchButton = document.getElementById('searchButton');
        const searchInputModal = document.getElementById('searchInputModal');
        
        searchButton.addEventListener('click', () => {
            searchInputModal.style.display = 'block';
        });
        
        document.addEventListener('click', (event) => {
            if (event.target === searchInputModal) {
                searchInputModal.style.display = 'none';
            }
        });
        
        // Initialize the chart
        // Note: The D3.js chart code should be included here
        // ... existing D3.js code ...
    </script>
    
    <script>
        // Load the data
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'https://datamb.football/database/TEAM/teamplots.csv', false);
        xhr.send(null);
        
        let csvData = xhr.responseText;
        
        let extraHeaderRow = 'ID,Player,Top 7 Leagues,Goals per 90,xG per 90,Shots on target per 90,Shots on target %,Passes completed,Pass accuracy %,Possession %,Positional attacks per 90,Counter attacks per 90,Touches in the box per 90,Goals conceded per 90,SoT against per 90,Defensive duels per 90,Defensive duel %,Aerial duels per 90,Aerial duels %,Passes per possession,PPDA\n';
        
        // Concatenate the extra header row with the fetched CSV data
        csvData = extraHeaderRow + csvData;
        
        var rows = csvData.trim().split('\n');
        var header = rows[0].split(',');
        var data = rows.slice(1).map(function(row) {
            return row.split(',').map(function(d, i) {
                if (i >= 3) {
                    return parseFloat(d);
                } else {
                    return d;
                }
            });
        });
        
        var margin = { top: 40, right: 80, bottom: 100, left: 100 };
        var width = 1040 - margin.left - margin.right;
        var height = 764 - margin.top - margin.bottom;
        
        // Define league colors for clicked circles
        var leagueColors = {
            "Premier League": "rgba(255, 0, 0, 0.7)",      // Red
            "La Liga": "rgba(255, 165, 0, 0.7)",           // Orange
            "Bundesliga": "rgba(255, 255, 0, 0.7)",        // Yellow
            "Serie A": "rgba(0, 128, 0, 0.7)",             // Green
            "Ligue 1": "rgba(0, 0, 255, 0.7)",             // Blue
            "Eredivisie": "rgba(75, 0, 130, 0.7)",         // Indigo
            "Primeira Liga": "rgba(238, 130, 238, 0.7)"    // Violet
        };

        // Function to get color based on league
        function getLeagueColor(league) {
            return leagueColors[league] || "rgba(255, 0, 0, 0.7)"; // Default to red if league not found
        }
        
        // Calculate container width to center the chart
        function updateChartDimensions() {
            var containerWidth = document.querySelector('.plot-container').clientWidth;
            var svgWidth = Math.min(1040, containerWidth - 60);
            width = svgWidth - margin.left - margin.right;
            
            // Calculate height to maintain aspect ratio
            var aspectRatio = 764/1040;
            var svgHeight = svgWidth * aspectRatio;
            height = svgHeight - margin.top - margin.bottom;
            
            // Update SVG dimensions
            d3.select("#scatter-plot")
                .attr("width", svgWidth)
                .attr("height", svgHeight);
        }
        
        // Call on load and on window resize
        updateChartDimensions();
        window.addEventListener('resize', function() {
            updateChartDimensions();
            updateChart();
        });
        
        var medianLinesVisible = false;
        
        var selectX = d3.select("#select-x");
        var selectY = d3.select("#select-y");
        
        var names = data.map(function(row) {
            return row[1];
        });
        
        // Populate the select dropdowns
        header.slice(3).forEach(function(metric) {
            selectX.append("option")
                .text(metric)
                .attr("value", metric);
            selectY.append("option")
                .text(metric)
                .attr("value", metric);
        });
        
        // Set default values for the selectors
        selectX.property("value", header[3]);
        selectY.property("value", header[4]);
        
        // Create the SVG container
        var svg = d3.select("#scatter-plot")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
        var xMetric = header[3];
        var yMetric = header[4]; // Use a different default for Y axis
        
        var xScale = d3.scaleLinear()
            .range([0, width]);
        var yScale = d3.scaleLinear()
            .range([height, 0]);
        
        var xAxis = d3.axisBottom(xScale).tickSize(0);
        var yAxis = d3.axisLeft(yScale).tickSize(0);
        
        // Add X axis
        var gXAxis = svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", "translate(0," + height + ")");
        
        // Add Y axis
        var gYAxis = svg.append("g")
            .attr("class", "y-axis");
        
        // Add axis labels
        var xLabel = svg.append("text")
            .attr("class", "x-label")
            .attr("text-anchor", "middle")
            .attr("x", width / 2)
            .attr("y", height + 40)
            .style("font-family", "Inter, sans-serif")
            .style("font-size", "14px");
        
        var yLabel = svg.append("text")
            .attr("class", "y-label")
            .attr("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("y", -60)
            .attr("x", -height / 2)
            .style("font-family", "Inter, sans-serif")
            .style("font-size", "14px");
        
        // Create tooltip
        var tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip");
        
        var clickedCircles = [];
        var filteredData = data;
        var filteredNames = names;
        var circles;
        
        // Function to update the chart
        function updateChart() {
            // Get the selected league
            var selectedLeague = document.getElementById("select-league").value;
            
            // Filter data based on selected league
            if (selectedLeague === "all") {
                filteredData = data;
            } else if (selectedLeague === "Top 5 Leagues") {
                filteredData = data.filter(function(d) {
                    return d[2] === "Premier League" || d[2] === "La Liga" || 
                           d[2] === "Bundesliga" || d[2] === "Serie A" || 
                           d[2] === "Ligue 1";
                });
            } else {
                filteredData = data.filter(function(d) {
                    return d[2] === selectedLeague;
                });
            }
            
            // Update filtered names
            filteredNames = filteredData.map(function(d) {
                return d[1];
            });
            
            // Get the selected metrics
            xMetric = selectX.property("value");
            yMetric = selectY.property("value");
            
            // Update scales
            xScale.domain([
                d3.min(filteredData, function(d) { return d[header.indexOf(xMetric)] * 0.9; }),
                d3.max(filteredData, function(d) { return d[header.indexOf(xMetric)] * 1.1; })
            ]);
            
            yScale.domain([
                d3.min(filteredData, function(d) { return d[header.indexOf(yMetric)] * 0.9; }),
                d3.max(filteredData, function(d) { return d[header.indexOf(yMetric)] * 1.1; })
            ]);
            
            // Update axes
            gXAxis.call(xAxis);
            gYAxis.call(yAxis);
            
            // Update axis labels
            xLabel.text(xMetric);
            yLabel.text(yMetric);
            
            // Remove existing circles and labels
            svg.selectAll("circle").remove();
            svg.selectAll(".team-label").remove();
            svg.selectAll(".xy-line").remove(); // Remove any existing diagonal reference line
            svg.selectAll(".xy-line-bg").remove(); // Remove line background
            svg.selectAll(".xy-line-label").remove(); // Remove line label
            svg.selectAll(".xy-line-label-bg").remove(); // Remove label background
            svg.selectAll(".performance-label").remove(); // Remove performance labels
            svg.selectAll("linearGradient#line-gradient").remove(); // Remove gradient definition
            svg.selectAll("marker#arrow-over, marker#arrow-under").remove(); // Remove arrow markers
            svg.selectAll(".xy-line-hover").remove(); // Remove hover detection element
            
            // Add diagonal reference line for xG vs Goals
            if ((xMetric === 'xG per 90' && yMetric === 'Goals per 90') || 
                (xMetric === 'Goals per 90' && yMetric === 'xG per 90')) {
                
                // Variable to track hover timer for the diagonal line
                var diagonalLineHoverTimer = null;
                
                // Calculate the intersection points for the x=y line
                var minX = d3.min(filteredData, d => d[header.indexOf(xMetric)]);
                var maxX = d3.max(filteredData, d => d[header.indexOf(xMetric)]);
                var minY = d3.min(filteredData, d => d[header.indexOf(yMetric)]);
                var maxY = d3.max(filteredData, d => d[header.indexOf(yMetric)]);
                
                // Get the smaller max between the x and y axes
                var maxVal = Math.min(maxX, maxY);
                
                // Get the larger min between the x and y axes
                var minVal = Math.max(minX, minY);
                
                // Now draw the line only within these bounds
                svg.append("line")
                    .attr("class", "xy-line")
                    .attr("x1", xScale(minVal))
                    .attr("y1", yScale(minVal))
                    .attr("x2", xScale(maxVal))
                    .attr("y2", yScale(maxVal))
                    .style("stroke", "#2ecc71") // Simple green color
                    .style("stroke-width", "2")
                    .style("stroke-dasharray", "5,3");
                
                // Add invisible wider line for better hover detection
                svg.append("line")
                    .attr("class", "xy-line-hover")
                    .attr("x1", xScale(minVal))
                    .attr("y1", yScale(minVal))
                    .attr("x2", xScale(maxVal))
                    .attr("y2", yScale(maxVal))
                    .style("stroke", "transparent")
                    .style("stroke-width", "15")
                    .style("cursor", "help")
                    .on("mouseover", function() {
                        // Clear any existing timer
                        if (diagonalLineHoverTimer) {
                            clearTimeout(diagonalLineHoverTimer);
                        }
                        
                        // Capture the event coordinates
                        var eventX = d3.event.pageX;
                        var eventY = d3.event.pageY;
                        
                        // Set a new timer with delay
                        diagonalLineHoverTimer = setTimeout(function() {
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", 0.9);
                            
                            var tooltipContent = "<strong>G = xG Line</strong><br/>";
                            
                            // Check which axis is which and provide the correct explanation
                            if (xMetric === 'xG per 90' && yMetric === 'Goals per 90') {
                                tooltipContent += "Teams above this line are scoring more goals than expected.<br/>" +
                                    "Teams below this line are scoring fewer goals than expected.";
                            } else {
                                tooltipContent += "Teams right of this line are scoring more goals than expected.<br/>" +
                                    "Teams left of this line are scoring fewer goals than expected.";
                            }
                            
                            tooltip.html(tooltipContent)
                                .style("left", (eventX + 10) + "px")
                                .style("top", (eventY - 28) + "px");
                        }, 550); // 550ms delay before showing tooltip
                    })
                    .on("mouseout", function() {
                        // Clear the timer if mouse leaves before tooltip is shown
                        if (diagonalLineHoverTimer) {
                            clearTimeout(diagonalLineHoverTimer);
                            diagonalLineHoverTimer = null;
                        }
                        
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
            }
            
            // Add median lines if enabled
            if (medianLinesVisible) {
                // Calculate medians
                var xMedian = d3.median(filteredData, function(d) { 
                    return d[header.indexOf(xMetric)]; 
                });
                
                var yMedian = d3.median(filteredData, function(d) { 
                    return d[header.indexOf(yMetric)]; 
                });
                
                // Add X median line
                svg.append("line")
                    .attr("class", "median-line")
                    .attr("x1", xScale(xMedian))
                    .attr("y1", 0)
                    .attr("x2", xScale(xMedian))
                    .attr("y2", height)
                    .style("stroke", "rgba(0, 0, 0, 0.3)")
                    .style("stroke-dasharray", "4");
                
                // Add Y median line
                svg.append("line")
                    .attr("class", "median-line")
                    .attr("x1", 0)
                    .attr("y1", yScale(yMedian))
                    .attr("x2", width)
                    .attr("y2", yScale(yMedian))
                    .style("stroke", "rgba(0, 0, 0, 0.3)")
                    .style("stroke-dasharray", "4");
            } else {
                svg.selectAll(".median-line").remove();
            }
            
            // Add circles
            circles = svg.selectAll("circle")
                .data(filteredData)
                .enter()
                .append("circle")
                .attr("cx", function(d) { return xScale(d[header.indexOf(xMetric)]); })
                .attr("cy", function(d) { return yScale(d[header.indexOf(yMetric)]); })
                .attr("r", 8)
                .style("fill", function(d) {
                    // Check if this circle is in the clicked circles array
                    if (clickedCircles.includes(d[1])) {
                        return getLeagueColor(d[2]);
                    }
                    return "rgba(70, 130, 180, 0.7)";
                })
                .style("stroke", function(d) {
                    return clickedCircles.includes(d[1]) ? "#000" : "none";
                })
                .style("stroke-width", function(d) {
                    return clickedCircles.includes(d[1]) ? 2 : 0;
                })
                .style("cursor", "pointer")
                .on("mouseover", function(d) {
                    // Store the original fill color before hover
                    var originalFill = d3.select(this).style("fill");
                    d3.select(this)
                        .attr("original-fill", originalFill) // Store original fill for mouseout
                        .transition()
                        .duration(200)
                        .attr("r", 10)
                        .style("fill", getLeagueColor(d[2])); // Show league color on hover
                    
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", 0.9);
                    
                    tooltip.html("<strong>" + d[1] + "</strong><br/>" +
                                xMetric + ": " + d[header.indexOf(xMetric)].toFixed(2) + "<br/>" +
                                yMetric + ": " + d[header.indexOf(yMetric)].toFixed(2))
                        .style("left", (d3.event.pageX + 10) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    // Get the original fill color
                    var isClicked = clickedCircles.includes(d[1]);
                    
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr("r", 8)
                        .style("fill", function() {
                            // If the circle is clicked, keep the league color
                            // Otherwise, revert to the default blue
                            return isClicked ? getLeagueColor(d[2]) : "rgba(70, 130, 180, 0.7)";
                        });
                    
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                })
                .on("click", function(d) {
                    // Check if this is a search match
                    var isSearchMatch = d3.select(this).classed("search-match");
                    
                    // If it's a search match, clear the search first
                    if (isSearchMatch) {
                        resetSearch();
                    }
                    
                    // Toggle clicked state
                    var index = clickedCircles.indexOf(d[1]);
                    
                    if (index === -1) {
                        // Add to clicked circles
                        clickedCircles.push(d[1]);
                        d3.select(this)
                            .style("fill", getLeagueColor(d[2]))
                            .style("stroke", "#000")
                            .style("stroke-width", 2);
                            
                        // Add team label
                        addTeamLabel(d);
                    } else {
                        // Remove from clicked circles
                        clickedCircles.splice(index, 1);
                        d3.select(this)
                            .style("fill", "rgba(70, 130, 180, 0.7)")
                            .style("stroke", "none");
                            
                        // Remove team label
                        svg.selectAll(".team-label-" + d[1].replace(/\s+/g, '-').toLowerCase()).remove();
                    }
                    
                    // Update button text based on whether all circles are selected
                    updateSelectAllButtonText();
                    
                    // Update the legend
                    var selectedLeague = document.getElementById("select-league").value;
                    updateLeagueLegend(selectedLeague);
                });
                
            // Add labels for clicked teams
            clickedCircles.forEach(function(teamName) {
                var teamData = filteredData.find(function(d) {
                    return d[1] === teamName;
                });
                
                if (teamData) {
                    addTeamLabel(teamData);
                }
            });
                
            // Update button text based on current selection state
            updateSelectAllButtonText();
            
            // Update the legend to show only relevant leagues
            updateLeagueLegend(selectedLeague);
        }
        
        // Function to update the "Click All" button text
        function updateSelectAllButtonText() {
            var selectAllButton = document.querySelector('.select-all-button');
            var allSelected = filteredData.every(function(d) {
                return clickedCircles.includes(d[1]);
            });
            
            selectAllButton.textContent = allSelected ? "Unclick All" : "Click All";
        }
        
        // Add event listeners to the selectors
        selectX.on("change", updateChart);
        selectY.on("change", updateChart);
        
        // Function to remove special characters and diacritics for better search matching
        function removeSpecialCharsAndDiacritics(str) {
            if (!str) return '';
            return str.normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
                .replace(/Ø/g, 'O')
                .replace(/ø/g, 'o');
        }
        
        // Add search functionality
        var searchBar = document.getElementById("search-bar");
        
        searchBar.addEventListener("input", function() {
            var searchTerm = searchBar.value.toLowerCase();
            
            if (searchTerm === '') {
                resetSearch();
                return;
            }
            
            // Normalize search term to handle special characters and diacritics
            var normalizedSearchTerm = removeSpecialCharsAndDiacritics(searchTerm);
            
            // Reset previous search styling
            svg.selectAll("circle").classed("search-match", false)
                .style("fill", function(d) {
                    // Restore original fill color
                    return clickedCircles.includes(d[1]) ? getLeagueColor(d[2]) : "rgba(70, 130, 180, 0.7)";
                })
                .style("stroke", function(d) {
                    return clickedCircles.includes(d[1]) ? "#000" : "none";
                })
                .style("stroke-width", function(d) {
                    return clickedCircles.includes(d[1]) ? 2 : 0;
                })
                .style("filter", "none")
                .each(function() {
                    // Reset any inline styles that might interfere with our animation
                    d3.select(this).style("r", null);
                });
            
            svg.selectAll(".team-label")
                .classed("search-match", false)
                .classed("search-dimmed", false);
            
            // Find matching teams
            var matchingTeams = [];
            
            // Apply new search styling
            svg.selectAll("circle").filter(function(d) {
                var teamName = d[1].toLowerCase();
                var normalizedTeamName = removeSpecialCharsAndDiacritics(teamName);
                
                // Check both original and normalized versions for better matching
                var isMatch = teamName.includes(searchTerm) || normalizedTeamName.includes(normalizedSearchTerm);
                
                if (isMatch) {
                    matchingTeams.push(d[1]);
                }
                
                return isMatch;
            })
            .classed("search-match", true)
            .each(function() {
                // Bring matching circles to front
                this.parentNode.appendChild(this);
            });
            
            // If we have matches, dim non-matching labels
            if (matchingTeams.length > 0) {
                // First dim all labels
                svg.selectAll(".team-label").classed("search-dimmed", true);
                
                // Then highlight matching labels
                svg.selectAll(".team-label").filter(function() {
                    var labelText = d3.select(this).text();
                    return matchingTeams.includes(labelText);
                })
                .classed("search-match", true)
                .classed("search-dimmed", false)
                .each(function() {
                    // Bring matching labels to front
                    this.parentNode.appendChild(this);
                });
                
                // Add labels for matching teams that don't have labels yet
                matchingTeams.forEach(function(teamName) {
                    // Check if this team already has a label
                    var labelClass = "team-label-" + teamName.replace(/\s+/g, '-').toLowerCase();
                    if (svg.select("." + labelClass).size() === 0) {
                        // Find the team data
                        var teamData = filteredData.find(function(d) {
                            return d[1] === teamName;
                        });
                        
                        if (teamData) {
                            // Add the label
                            addTeamLabel(teamData);
                            // Apply search match styling
                            svg.select("." + labelClass).classed("search-match", true);
                        }
                    }
                });
            }
        });
        
        function resetSearch() {
            // Clear the search input field
            searchBar.value = '';
            
            // Reset circle styling
            svg.selectAll("circle")
                .classed("search-match", false)
                .style("fill", function(d) {
                    return clickedCircles.includes(d[1]) ? getLeagueColor(d[2]) : "rgba(70, 130, 180, 0.7)";
                })
                .style("stroke", function(d) {
                    return clickedCircles.includes(d[1]) ? "#000" : "none";
                })
                .style("stroke-width", function(d) {
                    return clickedCircles.includes(d[1]) ? 2 : 0;
                })
                .style("filter", "none")
                .each(function() {
                    // Reset any inline styles that might interfere with our animation
                    d3.select(this).style("r", null);
                    // Stop any ongoing animations
                    d3.select(this).interrupt();
                });
                
            // Reset label styling
            svg.selectAll(".team-label")
                .classed("search-match", false)
                .classed("search-dimmed", false)
                .each(function() {
                    // Stop any ongoing animations
                    d3.select(this).interrupt();
                });
                
            // Remove labels for teams that aren't clicked
            svg.selectAll(".team-label").each(function() {
                var label = d3.select(this);
                var teamName = label.text();
                
                if (!clickedCircles.includes(teamName)) {
                    label.remove();
                }
            });
        }
        
        // Toggle median lines
        var toggleButton = document.getElementById("toggle-median-lines");
        toggleButton.addEventListener("click", function() {
            medianLinesVisible = !medianLinesVisible;
            updateChart();
        });
        
        // Select all circles
        function selectAllCircles() {
            // Check if all circles are already selected
            var allSelected = filteredData.every(function(d) {
                return clickedCircles.includes(d[1]);
            });
            
            if (allSelected) {
                // Deselect all circles
                clickedCircles = [];
                svg.selectAll("circle")
                    .style("fill", "rgba(70, 130, 180, 0.7)")
                    .style("stroke", "none");
                
                // Remove all team labels
                svg.selectAll(".team-label").remove();
            } else {
                // Select all circles
                svg.selectAll("circle").each(function(d) {
                    if (!clickedCircles.includes(d[1])) {
                        clickedCircles.push(d[1]);
                        d3.select(this)
                            .style("fill", getLeagueColor(d[2]))
                            .style("stroke", "#000")
                            .style("stroke-width", 2);
                    }
                });
                
                // Add labels for all teams
                filteredData.forEach(function(d) {
                    addTeamLabel(d);
                });
            }
            
            // Update button text
            updateSelectAllButtonText();
            
            // Update the legend
            var selectedLeague = document.getElementById("select-league").value;
            updateLeagueLegend(selectedLeague);
        }
        
        // Position filter buttons
        document.querySelectorAll('.position-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.position-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                // Filter based on position
                // This is a placeholder - you would need to implement the actual filtering logic
                // based on your data structure
                updateChart();
            });
        });
        
        // Initialize the chart
        updateChart();
        
        // Function to update the league legend based on selected league
        function updateLeagueLegend(selectedLeague) {
            var legendContainer = document.getElementById('league-legend');
            
            // If only one league is selected (and it's not "all" or "Top 5 Leagues"), hide the legend completely
            if (selectedLeague !== "all" && selectedLeague !== "Top 5 Leagues") {
                legendContainer.style.display = 'none';
                return;
            }
            
            // Hide the legend if no teams are clicked
            if (clickedCircles.length === 0) {
                legendContainer.style.display = 'none';
                return;
            }
            
            // Otherwise, show the legend
            legendContainer.style.display = 'flex';
            legendContainer.innerHTML = ''; // Clear existing legend
            
            // Add a title for the legend
            var legendTitle = document.createElement('div');
            legendTitle.style.fontWeight = 'bold';
            legendTitle.style.marginRight = '15px';
            legendContainer.appendChild(legendTitle);
            
            // Determine which leagues to show in the legend
            var leaguesToShow = [];
            
            if (selectedLeague === "all") {
                // Show all leagues
                leaguesToShow = Object.keys(leagueColors);
            } else if (selectedLeague === "Top 5 Leagues") {
                // Show only Top 5 leagues
                leaguesToShow = ["Premier League", "La Liga", "Bundesliga", "Serie A", "Ligue 1"];
            }
            
            // Add an item for each relevant league
            leaguesToShow.forEach(function(league) {
                var legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                
                var colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = leagueColors[league];
                
                var leagueText = document.createElement('span');
                leagueText.textContent = league;
                
                legendItem.appendChild(colorBox);
                legendItem.appendChild(leagueText);
                legendContainer.appendChild(legendItem);
            });
        }
        
        // Search modal functionality
        const xhr1 = new XMLHttpRequest();
        xhr1.open('GET', 'https://datamb.football/database/searchbar.csv', false);
        xhr1.send(null);
        
        let dataCSV = xhr1.responseText;
        const dataLines = dataCSV.split('\n');
        const searchInput = document.getElementById('searchInput');
        const autocompleteBox = document.getElementById('autocompleteBox');
        
        const data1 = dataLines.map(line => {
            const [name, link] = line.split(',');
            return { name, link };
        });
        
        function search2(query) {
            autocompleteBox.innerHTML = '';
            
            const normalizedQuery = query.toLowerCase();
            const matches = data1.filter(item => {
                const normalizedName = item.name ? item.name.toLowerCase() : '';
                return normalizedName.includes(normalizedQuery);
            });
            
            if (matches.length === 0) {
                autocompleteBox.style.display = 'none';
                return;
            }
            
            matches.forEach(match => {
                if (match.name && match.link) {
                    const div = document.createElement('div');
                    const a = document.createElement('a');
                    a.href = match.link;
                    a.textContent = match.name;
                    div.appendChild(a);
                    autocompleteBox.appendChild(div);
                }
            });
            
            autocompleteBox.style.display = 'block';
        }
        
        searchInput.addEventListener('input', () => {
            const query = searchInput.value;
            if (query.trim() === '') {
                autocompleteBox.style.display = 'none';
            } else {
                search2(query);
            }
        });
        
        // Function to add a team label
        function addTeamLabel(d) {
            var x = xScale(d[header.indexOf(xMetric)]);
            var y = yScale(d[header.indexOf(yMetric)]);
            
            // Create a unique class name for this team's label
            var teamClass = "team-label-" + d[1].replace(/\s+/g, '-').toLowerCase();
            
            // Check if this label already exists (avoid duplicates)
            if (svg.select("." + teamClass).size() > 0) {
                return;
            }
            
            // Create the label
            var label = svg.append("text")
                .attr("class", "team-label " + teamClass)
                .attr("x", x + 12)
                .attr("y", y + 4)
                .text(d[1])
                .style("font-family", "Inter, sans-serif")
                .style("font-size", "12px")
                .style("font-weight", "500")
                .style("fill", "#333");
                
            // Position the label to avoid overlaps
            positionLabelToAvoidOverlap(label, x, y);
        }
        
        // Function to position a label to avoid overlaps with other labels
        function positionLabelToAvoidOverlap(label, x, y) {
            // Get all existing labels except the current one
            var allLabels = svg.selectAll(".team-label").filter(function() {
                return this !== label.node();
            });
            
            // Get the bounding box of the new label
            var labelBox = label.node().getBBox();
            
            // Define possible positions to try (in order of preference)
            var positions = [
                { x: x + 12, y: y + 4 },           // Right (default)
                { x: x + 12, y: y - 10 },          // Top-right
                { x: x + 12, y: y + 18 },          // Bottom-right
                { x: x - labelBox.width - 5, y: y + 4 },  // Left
                { x: x - labelBox.width - 5, y: y - 10 }, // Top-left
                { x: x - labelBox.width - 5, y: y + 18 }, // Bottom-left
                { x: x - labelBox.width/2, y: y - 15 },   // Top
                { x: x - labelBox.width/2, y: y + 25 }    // Bottom
            ];
            
            // Try each position until we find one without overlaps
            var bestPosition = findPositionWithoutOverlap(positions, allLabels, labelBox);
            
            // Apply the best position
            label.attr("x", bestPosition.x)
                 .attr("y", bestPosition.y);
        }
        
        // Function to find a position without overlap
        function findPositionWithoutOverlap(positions, existingLabels, labelBox) {
            // Try each position
            for (var i = 0; i < positions.length; i++) {
                var pos = positions[i];
                var hasOverlap = false;
                
                // Create a rectangle for this position
                var testRect = {
                    x1: pos.x,
                    y1: pos.y - labelBox.height,
                    x2: pos.x + labelBox.width,
                    y2: pos.y + 5
                };
                
                // Check for overlaps with existing labels
                existingLabels.each(function() {
                    var existingBox = d3.select(this).node().getBBox();
                    var existingX = parseFloat(d3.select(this).attr("x"));
                    var existingY = parseFloat(d3.select(this).attr("y"));
                    
                    var existingRect = {
                        x1: existingX,
                        y1: existingY - existingBox.height,
                        x2: existingX + existingBox.width,
                        y2: existingY + 5
                    };
                    
                    // Check if rectangles overlap
                    if (!(testRect.x2 < existingRect.x1 || 
                          testRect.x1 > existingRect.x2 || 
                          testRect.y2 < existingRect.y1 || 
                          testRect.y1 > existingRect.y2)) {
                        hasOverlap = true;
                    }
                });
                
                // If no overlap, use this position
                if (!hasOverlap) {
                    return pos;
                }
            }
            
            // If all positions have overlaps, add a small random offset to the default position
            return {
                x: positions[0].x + (Math.random() * 20 - 10),
                y: positions[0].y + (Math.random() * 20 - 10)
            };
        }
        
        // Modify updateChart to reposition labels when the chart changes
        var originalUpdateChart = updateChart;
        updateChart = function() {
            // Call the original updateChart function
            originalUpdateChart();
            
            // Reposition all labels to avoid overlaps
            setTimeout(function() {
                var allLabels = svg.selectAll(".team-label");
                
                // Process labels one by one
                allLabels.each(function() {
                    var label = d3.select(this);
                    var teamName = label.text();
                    
                    // Find the team data
                    var teamData = filteredData.find(function(d) {
                        return d[1] === teamName;
                    });
                    
                    if (teamData) {
                        var x = xScale(teamData[header.indexOf(xMetric)]);
                        var y = yScale(teamData[header.indexOf(yMetric)]);
                        
                        // Reposition this label
                        positionLabelToAvoidOverlap(label, x, y);
                    }
                });
            }, 10); // Small delay to ensure DOM is updated
        };
    </script>
</body>
</html>


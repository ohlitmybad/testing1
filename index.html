<!DOCTYPE html>
<html>
<head>	
  <meta name="language" content="en">
<link rel="canonical" href="https://datamb.football/[PLAYER_NAME]_Striker_stats/" />
<link rel="alternate" hreflang="x-default" href="https://datamb.football/[PLAYER_NAME]_Striker_stats/" />
<link rel="alternate" hreflang="en" href="https://datamb.football/[PLAYER_NAME]_Striker_stats/?lang=en" /> 
  <meta name="viewport" content="width=device-width, user-scalable=no">
  <title data-i18n="meta.title" data-template="prefix-name">[PLAYER_NAME] Football Stats and Visuals | DataMB</title>
  <link rel="shortcut icon" type="image/x-icon" href="https://datamb.football/favicon.ico">
  <meta name="description" data-i18n="meta.description" data-template="prefix-name" content="[PLAYER_NAME] 2024/25 data profile compared to strikers in Europe's Top 7 Leagues. Check out his statistics with our radar chart and plots, or compare [PLAYER_NAME] to other players using our data comparison tool.">
  <meta property="og:image" content="https://datamb.football/vignettes/profile.png">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@DataMB_">
  <meta name="twitter:title" content="[PLAYER_NAME] | DataMB">
  <meta name="twitter:image" content="https://datamb.football/vignettes/profile.png">
  <script>
    // Store template information before player names are replaced
    document.addEventListener('DOMContentLoaded', function() {
      // Store template information for elements with data-template attribute
      document.querySelectorAll('[data-template]').forEach(element => {
        const templateType = element.getAttribute('data-template');
        
        // Store the template pattern
        if (templateType === 'prefix-name') {
          // For elements where player name is at the beginning
          element.setAttribute('data-name-position', 'prefix');
        }
      });
    });
  </script>
  <script>
    (function() {
        var width = window.innerWidth;
        var viewportMeta = document.querySelector('meta[name="viewport"]');
        if (viewportMeta) {
  if (width < 681) {
          
        var initialScale = width / 681;
  viewportMeta.setAttribute('content', 'width=device-width, initial-scale=' + initialScale + ', user-scalable=no');
  } else {
              var fixedScale = 1;
    viewportMeta.setAttribute('content', 'width=device-width, initial-scale=' + fixedScale + ', user-scalable=no');
  
    }
      } 
  })();
  </script>
<link rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
<script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>
<script src="https://d3js.org/d3.v5.min.js"></script>
  


<style>


  
.footer {
    font-family: system-ui;
    background: #F2F2F2;
    padding: 20px;
    text-align: center;
    color: #fff;
  }
  
  .footer {
    left: 0;
    right: 0;
    bottom: 0;
  }
  
  .footer .logo {
    display: flex;
    justify-content: center;
  }
  
  .footer .description {
    font-size: 20px;
    margin-bottom: 0px;
  color: black;
  }
  
  .footer .info {
    font-size: 16px;
    opacity: 0.8;
  }
  
  .footer .divider {
    border: none;
    border-bottom: 1px solid #fff;
    margin: 25px 0;
    opacity: 0.2;
  }
  
  .footer .sub-footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  
  .footer .sub-footer .terms,
  .footer .sub-footer .privacy,
  .footer .sub-footer .glossary {
  font-size: 17px;
    margin-left: 10px;
    text-decoration: none;
    color: black;
  }
  
  .logo img {
    width: 50px;
    height: 50px;
  }
  
  
  
  .footer-content {
    display: flex;
    justify-content: space-between;
    align-items: flex-start; /* Align items at the top */
    flex-wrap: wrap; /* Add flex-wrap property to wrap the content on smaller screens */
  }
  
  .google-play-container {
    display: flex;
    flex-direction: column; /* Arrange items in a column */
    align-items: flex-end; /* Align items to the right */
    margin-top: -20px; /* Adjust the margin-top to remove the space */
  }
  
  .google-play-container img {
    width: 182px;
    height: 70px;
  }
  
  .description,
  .info,
  .divider,
  .sub-footer {
    flex-basis: 100%;
  color: black;
  }
  
  .footer p {
    margin-bottom: 0; 
  }
  

.footer .twitter-link svg {
  width: 25px;
  height: 24px;
  fill: #444444;
}



.search-input-modal {
    display: none;
    position: fixed; /* Change this to "fixed" to cover the entire viewport */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7); /* Increase opacity for better obscuring */
    z-index: 999; /* Ensure it's above other elements */
}

.search-input-container {
    position: absolute;
    top: 30%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #fff;
    padding: 20px;
    border-radius: 4px;
    z-index: 1000; /* Make sure it's on top of the modal background */
}

#searchInput {
            width: 340px;
            padding: 12px;
            border: 3px solid #ccc;
            border-radius: 4px;
            font-size: 19px;
            outline: none;
        }

        #autocompleteBox {
            width: 360px;
            max-height: 150px;
            overflow-y: auto;
            background-color: #fff;
        }


        #autocompleteBox ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #autocompleteBox li {
            margin: 0;
            padding: 5px;
        }

        #autocompleteBox {
            line-height: 2; /* Adjust the value as needed to control line spacing */
            text-align: center !important;

        }

        #autocompleteBox a {
            text-decoration: none;
            font-family: Arial, sans-serif;
            text-align: center !important;
            color: #333 !important;
            cursor: pointer; /* Add pointer cursor style to the anchor element */
        }

        #autocompleteBox li:hover {
            background-color: #f0f0f0;
        }
#searchButton {
  padding: 8.5px;  /* Reduced from 10px */
  background-color: #0074d9;
  color: #fff;
  border: none;
  width: 34px;  /* Reduced from 40px */
  height: 34px;  /* Reduced from 40px */
  border-radius: 50%;
  cursor: pointer;
  font-size: 17px;  /* Reduced from 20px */
}

/* Add this to control icon size */
#searchButton iconify-icon {
  font-size: 17px;  /* Match the button's font-size */
  display: flex;
  align-items: center;
  justify-content: center;
}

.header {
  font-family: system-ui;
  padding: 20px;
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.header .logo {
  display: flex;
  align-items: center;
  margin-right: auto; /* Push logo to the left */
}

.header .logo img {
  height: 34px;
  width: auto;
  opacity: 0.84;
}

.header .logo-text {
  margin-left: 10px;
  font-size: 23px;
color: #444444;
  font-weight: 600;
}

.header .navigation {
  display: flex;
  align-items: center;
  gap: 25px; /* Reduced gap between buttons */
  position: absolute;
  left: 50%;
  transform: translateX(-50%); /* Center the navigation */
}

/* Hide navigation on small screens */


.header .button {
  padding: 0.5rem 1rem;
  text-decoration: none;
  color: #333;
  line-height: 1.6;
  border-radius: 4px;
  transition: background-color 0.2s;
  font-size: 1.1rem;  /* Added larger font size */
}


.header .button:hover {
  background-color: #f0f0f0;
  color: #2563eb;

}



/* Group search and language buttons */
.header-right {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-left: auto; /* Push buttons to the right */
}

header a {
      color: black;
      text-decoration: none;
    }





.language-switcher-container {
  position: relative;
  display: none;
}

.language-button {
  background: none;
  border: none;
  cursor: pointer;
  padding: 10px;
  color: #444444;
  display: flex;
  align-items: center;
  font-size: 17px;
}

.language-button iconify-icon {
  font-size: 24px;
  opacity: 0.7;
}

.language-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  padding: 10px;
  width: 200px;
  z-index: 1000;
}

.language-option {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  cursor: pointer;
  border-radius: 4px;
  color: #444444;
  text-decoration: none;
}

.language-option:hover {
  background: #f5f5f5;
}

.language-option iconify-icon {
  margin-right: 10px;
  font-size: 20px;
}

.language-dropdown.show {
  display: block;
}

  /* BASIC STYLE ELEMENTS BELOW */
    
  .team-label {
    pointer-events: none;
    text-shadow: 0px 0px 2px white, 0px 0px 2px white, 0px 0px 2px white, 0px 0px 2px white;
}
  svg text.label {
      fill: #bcbcbc;
    }
  
  
  
    td.black {
      color: black !important;
    }
    td.red {
      color: red !important;
    }
    td.green {
      color: green !important;
    }
  text {
    font-family: Arial;
  }
  
  .result-color-blue {
    color: #3062FB !important;
    stroke: #3062FB;
    fill: #3062FB;
    fill-opacity: 0.02;
  }
  
  
  
  .radar-button {
    position:relative;
    left:-5px;
    align-items: center;
    background-color: #FFFFFF;
    border: 4px solid #135eb6; /* Add a border */
    border-radius: 35px;
    color: #0b57d0;
    width: 145px;
    height: 58px;
    cursor: pointer;
    font-size: 14px;
    font-family: 'Open Sans', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
  
  }
  
  .radar-button:hover {
    background-color: #f0f0f0; /* Light grey background on hover */
}
.plot-button:hover {
    background-color: #f0f0f0; /* Light grey background on hover */
}
  .plot-button {
    position:relative;
    left:40px;
    top: -11px;
    align-items: center;
    background-color: #FFFFFF;
    border: 4px solid #135eb6; /* Add a border */
    border-radius: 35px;
    color: #0b57d0;
    width: 145px;
    height: 58px;
    font-size: 14px;
    cursor: pointer;
    font-family: 'Open Sans', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;  
  }
  
  
        
  .metrics-table th {
    background-color: #ececec;
    color: #444444;
    font-weight: bold;
    padding: 9px;
    text-align: left;
  }
  
  .metrics-table td {
    padding: 9px;
    border: 1px solid #ccc;
  }
  
  .metrics-table tr:nth-child(even) {
    background-color: #f2f2f2;
  }
  
  .metrics-table tr:hover {
    background-color: #ddd;
  }
  .metrics-table tr:first-child td {
    font-size: 20px;
  }
  
  .metrics-table a {
    text-decoration: none; /* Remove underlining */

  }


  #metrics-table a {
    text-decoration: none; /* Remove underlining */
    color: purple; /* Set link color to purple */
  }

  

  

  /* FUNCTIONAL STYLE ELEMENTS BELOW */


  
  svg:nth-of-type(1) {
  height: 485px;
}
  


.metrics-table {
    width: 520px;
    font-family:'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
    border-collapse: collapse;
  }

  
  /* Ensure the container is centered and elements are responsive */
.container {
  display: flex;
  flex-direction: column; /* Stack elements vertically */
  justify-content: center;
  align-items: center; /* Center elements horizontally */
  width: 100%; /* Allow the container to take up full width */
  margin: 0 auto; /* Center the container itself */
}

/* For rows that should have elements side by side */
.desktop-row {
  display: flex;
  justify-content: center; /* Center the row contents */
  align-items: flex-start; /* Align elements to the top, preventing height stretching */
  flex-wrap: wrap; /* Allow wrapping on smaller screens */
  width: 100%;
  margin: 20px 0;
}

.radar-wrapper {
  position: relative;
top: 20px;
}


.scatter-plot-wrapper {
  position: relative;
top: 26px;
}

.scatter-plot-wrapper-2 {
  position: relative;
top: 26px;
left: -20px;
}



/* Limit the width of individual elements and center them */
.metric-table, .radar-wrapper, .scatter-plot-wrapper, .scatter-plot-wrapper-2 {
  flex: 1;
  min-width: 300px;
  max-width: 550px; /* Ensure no element exceeds 485px */
  margin: 0px 40px;
  align-self: center; /* Ensure the element itself is centered */
  text-align: center; /* Center text or content inside the div */
}



.scatter-plot, .scatter-plot-2 {
  max-height: 400px; /* Keep aspect ratio */
  max-width: 123%; /* Ensure it scales down on smaller screens */
}

/* Limit the width of the radar SVG */
.radar {
  width: 485px;
  height: auto; /* Keep aspect ratio */
  max-width: 100%; /* Ensure it scales down on smaller screens */
}

/* Wrapper for radar and button */
.radar-wrapper, .scatter-plot-wrapper, .scatter-plot-wrapper-2 {
  display: flex;
  flex-direction: column;
  align-items: center; /* Center the content inside the wrapper */
}

/* Ensure the buttons are centered below their respective elements */
.radar-button, .plot-button {
  text-align: center; /* Ensure the buttons are centered */
}

/* Mobile-specific layout: Stack elements vertically */
@media only screen and (max-width: 1048px) {
  .desktop-row {
    flex-direction: column; /* Stack elements vertically on smaller screens */
  }


    .metric-table, .radar-wrapper, .scatter-plot-wrapper, .scatter-plot-wrapper-2 {

  margin: 20px 40px;

}



.scatter-plot-wrapper, .scatter-plot-wrapper-2 {
top:-10px;
left: 0px

}
.radar-wrapper {

top: 0px;
left: 10px

}
.plot-button {
    position:relative;
    left:10px;
  }
}

  

  body {
    margin: 0 auto;
  }
  
  
  body, html {
  
  background-color: #ffffff !important;
  }

  #searchInput1 {
  display: none;
  }
  
  
  
  
  #searchButton1 {
    display: none;
  
  }
  
  

  
  #select-league {
    display: none;
  }
  
  
  #select-x,
  #select-y {
    display: none;
  }
  
  
svg text
.x-label,
.y-label,
.team-label,
.player-name,
.x-axis text,
.y-axis text {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    pointer-events: none;
}
  </style>


<header class="header">
  <div class="logo">
    <a href="https://datamb.football">
        <img src="https://datamb.football/logo.png" alt="[PLAYER_NAME] football statistics and data visuals. 2024/25 [PLAYER_NAME] player data profile compared to top 7 league players. Radar comparison and plot charts"/></a>
    <div class="logo-text"><a href="https://datamb.football">&nbsp;Radars</a></div>
  </div>
  <nav class="navigation">
    <a href="https://datamb.football/" class="button" data-i18n="header.home">Home</a>
    <a href="https://datamb.football/join" class="button" data-i18n="header.pro">Pro</a>
    <a href="https://datamb.football/guide" class="button" data-i18n="header.guide">Guide</a>
  </nav>
  <div class="header-right">
  <div class="search-container">
    <button id="searchButton"><iconify-icon icon="ion:search-outline"></iconify-icon></button>
</div>
  <div class="language-switcher-container">
    <button class="language-button" id="languageButton">
      <iconify-icon icon="heroicons:globe-alt"></iconify-icon>
    </button>
    <div class="language-dropdown" id="languageDropdown">
      <a href="?lang=en" class="language-option"><iconify-icon icon="flag:gb-4x3"></iconify-icon>English</a>
    </div>
  </div></div>
</header>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7677714701428206"
     crossorigin="anonymous"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.16.9/xlsx.full.min.js"></script>
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-PSBMXX80EF"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PSBMXX80EF');
</script>

<body>

<div class="search-input-modal" id="searchInputModal">
<div class="search-input-container">
    <input type="text" id="searchInput" placeholder="Enter a team or player name...">
    <div id="autocompleteBox"></div>
</div>
</div>


<script>
  const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://datamb.football/database/searchbar.csv', false); // false for synchronous request
xhr.send(null);

let dataCSV = xhr.responseText;

const _0x5a5c2d=_0x5142;(function(_0x4ae5e2,_0x171055){const _0x1f5ab4=_0x5142,_0x4cdb37=_0x4ae5e2();while(!![]){try{const _0x3afa22=parseInt(_0x1f5ab4(0xa8))/0x1*(-parseInt(_0x1f5ab4(0xb6))/0x2)+parseInt(_0x1f5ab4(0xbb))/0x3+-parseInt(_0x1f5ab4(0x9e))/0x4*(parseInt(_0x1f5ab4(0xa2))/0x5)+parseInt(_0x1f5ab4(0xae))/0x6+parseInt(_0x1f5ab4(0xbc))/0x7+-parseInt(_0x1f5ab4(0xaa))/0x8*(-parseInt(_0x1f5ab4(0xa0))/0x9)+-parseInt(_0x1f5ab4(0xbe))/0xa*(parseInt(_0x1f5ab4(0xab))/0xb);if(_0x3afa22===_0x171055)break;else _0x4cdb37['push'](_0x4cdb37['shift']());}catch(_0x1427be){_0x4cdb37['push'](_0x4cdb37['shift']());}}}(_0x52bb,0x59fa0));const dataLines=dataCSV[_0x5a5c2d(0xb5)]('\x0a'),searchButton=document[_0x5a5c2d(0xa5)](_0x5a5c2d(0xa1)),searchInputModal=document[_0x5a5c2d(0xa5)]('searchInputModal'),searchInput=document[_0x5a5c2d(0xa5)](_0x5a5c2d(0xc0)),autocompleteBox=document[_0x5a5c2d(0xa5)](_0x5a5c2d(0xb3)),data1=dataLines['map'](_0x25b9ec=>{const _0x188cb6=_0x5a5c2d,[_0x37829c,_0x135ccf]=_0x25b9ec[_0x188cb6(0xb5)](',');return{'name':_0x37829c,'link':_0x135ccf};});function _0x5142(_0x91cc0a,_0x361212){const _0x52bb26=_0x52bb();return _0x5142=function(_0x514259,_0x37adb4){_0x514259=_0x514259-0x99;let _0x29d9f9=_0x52bb26[_0x514259];return _0x29d9f9;},_0x5142(_0x91cc0a,_0x361212);}function _0x52bb(){const _0x3bd6c6=['replace','split','45174fxMLYv','appendChild','value','target','includes','501672VaVVkL','4952297iMiCMK','innerHTML','1488890idHbOF','trim','searchInput','input','addEventListener','link','style','block','1931500nwUXxJ','filter','756cBmWBX','searchButton','5JjKGuX','textContent','NFD','getElementById','normalize','name','6FNylug','display','9816GfedBU','44MmjqNG','createElement','click','3628404umwpKQ','toLowerCase','none','forEach','length','autocompleteBox'];_0x52bb=function(){return _0x3bd6c6;};return _0x52bb();}function removeDiacritics(_0x464131){const _0xe0c2fa=_0x5a5c2d;return _0x464131[_0xe0c2fa(0xa6)](_0xe0c2fa(0xa4))[_0xe0c2fa(0xb4)](/[\u0300-\u036f]/g,'');}function search2(_0x394513){const _0x949ea9=_0x5a5c2d;autocompleteBox[_0x949ea9(0xbd)]='';const _0x339607=removeDiacritics(_0x394513)[_0x949ea9(0xb4)](/[^\w\s]/g,'')[_0x949ea9(0xaf)](),_0x4cdd40=data1[_0x949ea9(0x9f)](_0x264779=>{const _0x40cc7d=_0x949ea9,_0x405e2a=removeDiacritics(_0x264779['name'])[_0x40cc7d(0xb4)](/[^\w\s]/g,'')[_0x40cc7d(0xaf)]();return _0x405e2a[_0x40cc7d(0xba)](_0x339607);});if(_0x4cdd40[_0x949ea9(0xb2)]===0x0){autocompleteBox[_0x949ea9(0x9c)]['display']=_0x949ea9(0xb0);return;}_0x4cdd40[_0x949ea9(0xb1)](_0x56128b=>{const _0x282f6f=_0x949ea9,_0x48093f=document[_0x282f6f(0xac)]('div'),_0x1b2914=document['createElement']('a');_0x1b2914['href']=_0x56128b[_0x282f6f(0x9b)],_0x1b2914[_0x282f6f(0xa3)]=_0x56128b[_0x282f6f(0xa7)],_0x48093f[_0x282f6f(0xb7)](_0x1b2914),autocompleteBox[_0x282f6f(0xb7)](_0x48093f);}),autocompleteBox['style'][_0x949ea9(0xa9)]=_0x949ea9(0x9d);}searchButton[_0x5a5c2d(0x9a)]('click',()=>{const _0x525d6c=_0x5a5c2d;searchInputModal[_0x525d6c(0x9c)][_0x525d6c(0xa9)]=_0x525d6c(0x9d);}),searchInput['addEventListener'](_0x5a5c2d(0x99),()=>{const _0x2e034c=_0x5a5c2d,_0x330e2e=searchInput[_0x2e034c(0xb8)];_0x330e2e[_0x2e034c(0xbf)]()===''?autocompleteBox[_0x2e034c(0x9c)][_0x2e034c(0xa9)]=_0x2e034c(0xb0):search2(_0x330e2e);}),document['addEventListener'](_0x5a5c2d(0xad),_0x697f09=>{const _0x27985e=_0x5a5c2d;_0x697f09[_0x27985e(0xb9)]===searchInputModal&&(searchInputModal[_0x27985e(0x9c)]['display']=_0x27985e(0xb0));});

</script>

	



<br> 
<div class="container">
  <div class="desktop-row">
    <div id="resultsTable" class="metric-table"></div>
    <div class="radar-wrapper">
      <svg class="radar"><g transform="translate(231.77,225.77)"><g class="axisWrapper">
        <g class="radar_label">
          <text class="label" data-type="Aerial%" data-idx="0" transform="translate(-23.6 -199) scale(1.3) rotate(-1.7)" data-i18n="radar.metrics.expected_assists">xA</text>
      </g>
      
      <g class="radar_label">
          <text class="label" data-type="Long%" data-idx="6" transform="matrix(0.65, -1.118, 1.118, 0.65, -200.21, -61.03) rotate(6)" data-i18n="radar.metrics.passes_to_box">Passes to box</text>
      </g>
      
      <g class="radar_label">
          <text class="label" data-type="Passes" data-idx="5" transform="matrix(-0.494, -1.209, 1.209, -0.494, -190, 63.54) rotate(3.87)" data-i18n="radar.metrics.expected_goals">xG</text>
      </g>
      
      <g class="radar_label">
          <text class="label" data-type="Exits" data-idx="4" transform="translate(-105.12 188.16) scale(1.3) rotate(21)" data-i18n="radar.metrics.non_penalty_goals">NPG</text>
      </g>
      
      <g class="radar_label">
          <text class="label" data-type="Aerial" data-idx="3" transform="translate(78.82 201.54) scale(1.3) rotate(-31)" data-i18n="radar.metrics.aerial_percentage">Aerial%</text>
      </g>
      
      <g class="radar_label">
          <text class="label" data-type="Def Actions" data-idx="2" transform="translate(203.22 -10.30) scale(1.3) rotate(99.11)" data-i18n="radar.metrics.passes_received">Passes Rec</text>
      </g>
      
      <g class="radar_label">
          <text class="label" data-type="Shotstopping" data-idx="1" transform="translate(125.64 -163.65) scale(1.3) rotate(49.49)" data-i18n="radar.metrics.attacking_actions">Att Actions</text>
      </g>
      
  <circle class="blackCircle" r="190" style="fill:none; stroke:#D3D3D3; stroke-width:1;"></circle>
  <circle class="gridCircle" r="190" style="fill: rgb(16, 135, 188); fill-opacity: 0.03;"></circle>
  <circle class="gridCircle" r="160" style="fill: rgb(16, 135, 188); fill-opacity: 0.03;"></circle>
  <circle class="gridCircle" r="120" style="fill: rgb(16, 135, 188); fill-opacity: 0.03;"></circle>
  <circle class="gridCircle" r="80" style="fill: rgb(16, 135, 188); fill-opacity: 0.03;"></circle>
  <circle class="gridCircle" r="40" style="fill: rgb(16, 135, 188); fill-opacity: 0.03;"></circle>
  <line x1="0" y1="0" x2="9.33" y2="189.4543362" stroke="#D3D3D3" stroke-width="1" transform="translate(-9.33, -189.4543362)"></line>
  <line x1="0" y1="0" x2="-142.0538533333333" y2="126.24" stroke="#D3D3D3" stroke-width="1" transform="translate(141.74184, -126.24)"></line>
  <line x1="0" y1="0" x2="-187.31589333333332" y2="-32.31413333333333" stroke="#D3D3D3" stroke-width="1" transform="translate(187.5574112, 32.2528)"></line>
  <line x1="0" y1="0" x2="-91.84497333333333" y2="-166.92245333333333" stroke="#D3D3D3" stroke-width="1" transform="translate(91.84497333333333, 166.21328)"></line>
  <line x1="0" y1="0" x2="72.99733333333333" y2="-175.84917333333335" stroke="#D3D3D3" stroke-width="1" transform="translate(-72.99997333333334, 175.334068)"></line>
  <line x1="0" y1="0" x2="182.73258666666666" y2="-52.67472" stroke="#D3D3D3" stroke-width="1" transform="translate(-182.7209384, 52.480128)"></line>
  <line x1="0" y1="0" x2="154.67849333333334" y2="109.91788799999999" stroke="#D3D3D3" stroke-width="1" transform="translate(-154.6883792222, -110.017215488)"></line>
  
  <g class="radarWrapper"></g> 
</g></g></svg>      <a href="https://datamb.football/strikers/">
  <button class="radar-button" data-i18n="st.radar.compare">Compare strikers</button>
</a>
</div>
</div>
  
  
<div class="desktop-row">

  <!-- Wrapper for scatter plot and button -->
  <div class="scatter-plot-wrapper">
    <svg id="scatter-plot" class="scatter-plot"></svg>
    <a href="https://datamb.football/join/">
      <button class="plot-button" data-i18n="plot.more">Plot more metrics</button>
    </a></div>


    <div class="scatter-plot-wrapper-2">
    <svg id="scatter-plot-2" class="scatter-plot-2"></svg>
    <a href="https://datamb.football/join/">
      <button class="plot-button" data-i18n="plot.more">Plot more metrics</button>
    </a>
  </div>
</div>
</div>
  
 

<input id="search-bar" style="display: none;">
<select id="select-league" style="display: none;"><option value="all"></option></select>
<select id="select-age" style="display: none;"><option value="all"></option></select>
<select id="select-x" style="display: none;"></select>
<select id="select-y" style="display: none;"></select>                   
<select id="select-size" style="display: none;"></select>

  <input type="text" id="searchInput1" class="search-bar" placeholder=""/>

<input type="button" id="searchButton1" value=""/>
  <center><br>

    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7677714701428206"
         crossorigin="anonymous"></script>
    <!-- radarplotsearch -->
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-7677714701428206"
         data-ad-slot="6673239737"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({});
    </script> <br></center>
  
  
    <script>
  
  
      const csvData = `Csvdata`;    


      const dataArray = csvData.split('\n').map(line => line.split(','));
  
      const colorClasses = ['result-color-blue'];
      
      let searchResults = []; // Declare the search results variable
      
      
      function removeSpecialChars(str) {
        return str.normalize('NFD').replace(/[\u0300-\u036f\s]/g, '');
      }
      
      function search(query) {
        const results = dataArray.filter(data =>
          removeSpecialChars(data[1].toLowerCase()).includes(removeSpecialChars(query.toLowerCase()))
        );
        return results;
      }
      
      function createTable(teamName, teamIndex, color) {
        const resultsTable = document.getElementById('resultsTable');
        const headerNames = [
          '',
          '',
          'Club',
          'League',
          'Age',
          'Position',
          'Season',
          'Passes received',
          'Aerial duel %',
          'Non-penalty goals',
          'Expected goals',
          'Passes to penalty area',
          'Expected assists',
          'Offensive actions',
          'Minutes played'
    
              ];
    
        // Translation keys for header names
        const headerTranslationKeys = [
          '',
          '',
          'table.club',
          'table.league',
          'table.age',
          'table.position',
          'table.season',
          'table.metrics.passes_received',
          'table.metrics.aerial_duel_success',
          'table.metrics.non_penalty_goals',
          'table.metrics.expected_goals',
          'table.metrics.passes_to_penalty_area',
          'table.metrics.expected_assists',
          'table.metrics.offensive_actions',
          'table.minutes_played'
        ];
        
      
        // Check if table headers exist
        const headersExist = resultsTable.querySelector('th') !== null;
      
        const table = headersExist ? resultsTable.querySelector('table') : document.createElement('table');
        table.classList.add('metrics-table');
      
        if (!headersExist) {
          // Create the table header
          const headerRow = document.createElement('tr');
          for (let i = 0; i < headerNames.length; i++) {
            const th = document.createElement('th');
            if (headerTranslationKeys[i]) {
              th.setAttribute('data-i18n', headerTranslationKeys[i]);
            }
            th.textContent = headerNames[i];
            headerRow.appendChild(th);
          }
        }
      

        const teamData = dataArray[teamIndex];

        for (let i = 1; i < headerNames.length; i++) {

          const dataRow = document.createElement('tr');

          const td1 = document.createElement('td');

          

          // Add data-i18n attribute to the first cell in each row

          if (headerTranslationKeys[i]) {

            td1.setAttribute('data-i18n', headerTranslationKeys[i]);

          }

          td1.textContent = headerNames[i];
          dataRow.appendChild(td1);
          
          const td2 = document.createElement('td');
          let value = teamData[i];
        
          if (i === 5) {
            const link = document.createElement('a');
            link.textContent = value;
            const positionKey = value.toLowerCase().replace(/[^a-z]/g, '');
            link.setAttribute('data-i18n', `positions.${positionKey}`);
            link.href = 'https://datamb.football/strikers'; // Replace with the URL you want to link to for cell 5
            td2.appendChild(link);
          } else if (i === 2) {
            const link = document.createElement('a');
            link.textContent = value;
            link.href = 'https://datamb.football/[TEAM_NAME]_Team_stats'; // Replace with the URL you want to link to for cell 2
            td2.appendChild(link);
          } else {
            if (i >= 7 && i <= 13) {
              value = parseFloat(value) * 100;
              const roundedValue = Math.round(value);
              const lastDigit = roundedValue % 10;
              let percentileSuffix = 'th';
              if (lastDigit === 1 && roundedValue !== 11) {
                percentileSuffix = 'st';
              } else if (lastDigit === 2 && roundedValue !== 12) {
                percentileSuffix = 'nd';
              } else if (lastDigit === 3 && roundedValue !== 13) {
                percentileSuffix = 'rd';
              }
                            // Store the numeric value separately
              const numericValue = roundedValue;
              
              // Create a span for the percentile suffix to make it translatable
              const valueSpan = document.createElement('span');
              valueSpan.textContent = numericValue;
              
const suffixSpan = document.createElement('span');
              if (percentileSuffix === 'th') {
                suffixSpan.setAttribute('data-i18n', 'table.percentile_suffix.th_suffix');
              } else if (percentileSuffix === 'st') {
                suffixSpan.setAttribute('data-i18n', 'table.percentile_suffix.st_suffix');
              } else if (percentileSuffix === 'nd') {
                suffixSpan.setAttribute('data-i18n', 'table.percentile_suffix.nd_suffix');
              } else if (percentileSuffix === 'rd') {
                suffixSpan.setAttribute('data-i18n', 'table.percentile_suffix.rd_suffix');
              }
              suffixSpan.textContent = percentileSuffix;
              
              
              const percentileSpan = document.createElement('span');
              percentileSpan.setAttribute('data-i18n', 'table.percentile');
              percentileSpan.textContent = ' percentile';
              
              td2.appendChild(valueSpan);
              td2.appendChild(suffixSpan);
              td2.appendChild(percentileSpan);
              
              // Set empty text content since we're using child nodes
              value = '';
            }
        
            if ([1, 2, 3, 4, 5, 6, 14].includes(i)) {
              td2.classList.add('black'); // Add the black class
            }
            

                          if (value !== '') {

              td2.textContent = value;

            }            td2.classList.add(color);
        
            if ([7, 8, 9, 10, 11, 12, 13].includes(i)) { 
              // Apply color based on value range
              let numericValue;
              if (value === '') {
                // If we've already processed this cell with spans
                numericValue = parseInt(td2.firstChild.textContent);
              } else {
                numericValue = parseFloat(value);
              }
              
              if (numericValue >= 75 && numericValue <= 100) {
                td2.classList.add('green');
              } else if (numericValue >= 0 && numericValue <= 25) {
                td2.classList.add('red');
              }
            }
          }
        
          dataRow.appendChild(td2);
          table.appendChild(dataRow);
        }
        
    if (!headersExist) {
      resultsTable.appendChild(table);
    }
      
        const combResults = dataArray[teamIndex].join(', ');
        console.log(combResults);
      
        const outerRadius = 190;
        const center = [0, 0];
        const angles = [
          0,
          (2 * Math.PI) / 7,
          (4 * Math.PI) / 7,
          (6 * Math.PI) / 7,
          (8 * Math.PI) / 7,
          (10 * Math.PI) / 7,
          (12 * Math.PI) / 7
        ];
      
        function axisValueToCartesian(axis, value) {
          let angle = angles[axis - 1];
          angle += (2 * Math.PI / 7) * 0.2;
          const x = 190 * value * Math.cos(angle);
          const y = 190 * value * Math.sin(angle);
          return { x, y };
        }
      
        const svg = document.querySelector('.radar');
        const radarWrapper = svg.appendChild(
          document.createElementNS('http://www.w3.org/2000/svg', 'g')
        );
        radarWrapper.setAttribute('transform', 'translate(231.77,225.77)');
        radarWrapper.innerHTML = '';
      
        const data = [];
        const rowCols = combResults.split(',');
        for (let i = 7; i < 14; i++) {
          data.push({ axis: i - 6, value: parseFloat(rowCols[i]) });
        }
      
        const points = data
          .map(({ axis, value }) => {
            const { x, y } = axisValueToCartesian(axis, value);
            return `${x},${y}`;
          })
          .join(' ');
      
        const polyline = document.createElementNS(
          'http://www.w3.org/2000/svg',
          'polyline'
        );
        polyline.setAttribute('class', `radarLines ${color}`);
        polyline.setAttribute('points', `${points} ${points.split(' ')[0]}`);
        polyline.setAttribute('stroke-width', '3');
        polyline.setAttribute('fill', 'none');
        radarWrapper.appendChild(polyline);
      
        const polygon = document.createElementNS(
          'http://www.w3.org/2000/svg',
          'polygon'
        );
        polygon.setAttribute('class', `radarPolygon ${color}`);
        polygon.setAttribute('points', points);
        polygon.style.fillOpacity = '0.2';
        radarWrapper.appendChild(polygon);
      
        data.forEach(({ axis, value }) => {
          const { x, y } = axisValueToCartesian(axis, value);
          const circle = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'circle'
          );
          circle.setAttribute('class', `radarCircle ${color}`);
          circle.style.fillOpacity = '0.86';
          circle.setAttribute('r', '6');
          circle.setAttribute('cx', x);
          circle.setAttribute('cy', y);
          radarWrapper.appendChild(circle);
        });
      }
      
      
      
      function toggleFilling() {
        const radarPolygons = document.querySelectorAll('.radarPolygon');
        radarPolygons.forEach(polygon => {
          polygon.style.fill = polygon.style.fill ? '' : 'none'; // Toggle the filling
        });
      }
      
      
        const teamNames = new Set();
      
      
      function createTableForTeam1() {
        const searchInput = document.getElementById('searchInput1');
        const searchButton = document.getElementById('searchButton1');
        const resultsTable = document.getElementById('resultsTable');
        const teamNamesList = document.createElement('ul');
        teamNamesList.style.fontFamily = 'Arial, sans-serif';
        teamNamesList.style.listStyleType = 'none';
        teamNamesList.style.paddingLeft = '9px';
        resultsTable.appendChild(teamNamesList);
        let searchCounter = 0;
      
        searchButton.addEventListener('click', function () {
          const searchQuery = searchInput.value;
          const results = search(searchQuery);
      
          // Reset the toggle state before performing a new search
          const radarPolygons = document.querySelectorAll('.radarPolygon');
          radarPolygons.forEach(polygon => {
            polygon.style.fill = '';
          });
      
          if (results) {
            const teamId = parseInt(results[0]);
            const teamName =
              results[1] + ' (' + results[2] + ', ' + results[3] + ') - ' + results[11] + ' min';
            const color = colorClasses[searchCounter % colorClasses.length];
      
            createTable(teamName, teamId - 1, color);
      
            searchCounter++;
          }
        });
      }
      
      createTableForTeam1();
      searchButton1.click(); // Trigger the search button click event
    
      
            
      
        </script>

       <script>
 
const allData = [];
let isFirstFileProcessed = false;

const urls = [
'https://datamb.football/database/CURRENT/TOP72425/ST/ST.xlsx',

];

const fetchPromises = urls.map(url => fetch(url).then(response => response.arrayBuffer()));

Promise.all(fetchPromises)
    .then(responses => {
        responses.forEach((data, index) => {
            const url = urls[index]; // Get the URL of the current file being processed
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            // Perform transformations
            // 1. Cut column C and paste it to the end
            const columnC = jsonData.map(row => row[2]);
            jsonData.forEach((row, index) => row.push(columnC[index]));
            jsonData.forEach(row => row.splice(2, 1));

            // 2. Delete specified columns
            const columnsToDelete = [27, 28, 29, 30, 40, 47, 48, 49, 55, 59, 61, 70, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 92, 105, 107, 123, 128];
            columnsToDelete.sort((a, b) => b - a); // Sort in descending order
            columnsToDelete.forEach(col => {
                jsonData.forEach(row => row.splice(col, 1));
            });

            // 3. Insert new columns and fill with appropriate values
            if (url === 'https://datamb.football/database/CURRENT/TOP72425/ST/ST.xlsx' && !isFirstFileProcessed) {
                // Include header only for the first file ('gk4.xlsx')
                jsonData.forEach(row => row.unshift(null)); // Insert empty column at the beginning
                jsonData[0][0] = "ID"; // Set header for the new column
                isFirstFileProcessed = true; // Mark the first file as processed
            } else {
                // Exclude header for all other files
                jsonData.forEach(row => row.unshift(undefined)); // Insert undefined at the beginning
            }

            // Fill ID column
            for (let i = 1; i < jsonData.length; i++) {
                jsonData[i][0] = i;
            }

            // 4. Replace ", m" with " m" and ", %" with " %"
            jsonData.forEach(row => {
                for (let i = 0; i < row.length; i++) {
                    if (typeof row[i] === 'string') {
                        row[i] = row[i].replace(', m', ' m').replace(', %', ' %');
                    }
                }
            });

            // 5. Collect the transformed data (excluding header for non-first 'gk4.xlsx')
            allData.push(...(url === 'https://datamb.football/database/CURRENT/TOP72425/ST/ST.xlsx' ? jsonData : jsonData.slice(1)));
        });

const leagues = {
 
  
"Primeira Liga": [
"Porto", "Benfica", "Sporting CP", "Sporting Braga", "Vitória Guimarães", "Gil Vicente", "Farense", "Moreirense", "Nacional", "Arouca", "Estoril", "Rio Ave", "Santa Clara", "Boavista", "Casa Pia AC", "Famalicão", "Estrela Amadora", "AVS", "AVS ",
],

"Ligue 1": [
"PSG", "Lille", "Nice", "Lens", "Nantes", "Reims", "Olympique Lyonnais", "Monaco", "Olympique Marseille", "Brest", "Saint-Étienne", "Montpellier", "Angers SCO", "Le Havre", "Rennes", "Auxerre", "Strasbourg", "Toulouse", 
],

"Premier League": [
"Manchester City", "Tottenham Hotspur", "Arsenal", "Manchester United", "Aston Villa", "Liverpool", "Southampton", "Everton", "Chelsea", "Brighton", "Newcastle United", "Wolverhampton Wanderers", "Fulham", "Crystal Palace", "Brentford", "Bournemouth", "West Ham United", "Leicester City", "Nottingham Forest", "Ipswich Town", "Wolverhampton",
],

"Bundesliga": [
"Borussia Dortmund", "Stuttgart", "Wolfsburg", "Bayer Leverkusen", "Borussia M'gladbach", "Augsburg", "Union Berlin", "Eintracht Frankfurt", "Bayern München", "Hoffenheim", "Mainz 05", "Werder Bremen", "RB Leipzig", "St. Pauli", "Holstein Kiel", "Freiburg", "Heidenheim", "Bochum", "Borussia Mgladbach",
],

"Eredivisie": [
"PSV", "Feyenoord", "Sparta Rotterdam", "Twente", "Utrecht", "Groningen", "PEC Zwolle", "Almere City", "NAC Breda", "NEC", "Fortuna Sittard", "Go Ahead Eagles", "Heerenveen", "Willem II", "Heracles", "AZ", "RKC Waalwijk", "Ajax",
],

"La Liga": [
"Valencia", "Atlético Madrid", "Barcelona", "Real Madrid", "Real Sociedad", "Real Betis", "Osasuna", "Deportivo Alavés", "Getafe", "Athletic Bilbao", "Girona", "Mallorca", "Villarreal", "Real Valladolid", "Rayo Vallecano", "Leganés", "Sevilla", "Las Palmas", "Celta de Vigo", "Espanyol",
],

"Serie A": [
"Milan", "Juventus", "Atalanta", "Lazio", "Napoli", "Roma", "Monza", "Internazionale", "Lecce", "Torino", "Parma", "Udinese", "Genoa", "Hellas Verona", "Bologna", "Fiorentina", "Cagliari", "Venezia", "Como", "Empoli", 
], 
  

};


function getTeamLeague(team) {
            for (const [league, teams] of Object.entries(leagues)) {
                if (teams.includes(team)) {
                    return league;
                }
            }
            return "Unknown League";
        }

        const outputLines = [];
let playerId = 1; // Initialize player ID counter

allData.forEach((row, index) => {
    // Ensure row has at least 3 elements
    if (row.length >= 3) {
        const team = row[2];
        const league = getTeamLeague(team);
        row[0] = playerId++; // Update the first element with the incremented player ID
        row[2] = league; // Replace the third element with the league information
        outputLines.push(row.join(",")); // Join the modified parts back into a line
    } else {
        // Handle rows that don't have at least 3 elements as needed
        outputLines.push(row.join(","));
    }
});

const output_data = outputLines.join("\n");

// Concatenate the extra header row with the fetched CSV data
let csvData = output_data;



        // Replace all '\n' characters with actual new rows in the CSV
        csvData = csvData.split('\\n').join('\n');




var rows = csvData.trim().split('\n');
var header = rows[0].split(',');
var data = rows.slice(1).map(function(row) {
  return row.split(',').map(function(d, i) {
    if (i >= 3) { // Assuming columns 2 and onwards contain numeric values
      return parseFloat(d);
    } else {
      return d;
    }
  });
});
        
        var margin = { top: 0, right: 0, bottom: 0, left: 0 };
        var width = 1082 - margin.left - margin.right;
        var height = 770 - margin.top - margin.bottom;
        
        // Define league colors for clicked circles
        var leagueColors = {
            "Premier League": "rgb(255, 0, 0, 0.7)",         // 1
            "La Liga": "rgb(255, 223, 0, 0.7)",             // 2
            "Bundesliga": "rgb(85, 209, 73, 0.7)",          // 3
            "Serie A": "rgb(0, 191, 255, 0.7)",             // 4
            "Ligue 1": "rgb(153, 50, 204, 0.7)",            // 5
            "Eredivisie": "rgb(255, 140, 0, 0.7)",          // 6
            "Primeira Liga": "rgb(255, 20, 147, 0.7)",      // 7
        };
        

        // Function to get color based on league
        function getLeagueColor(league) {
            return leagueColors[league] || "rgba(255, 0, 0, 0.7)"; // Default to red if league not found
        }
        
        var margin = { top: 40, right: 80, bottom: 100, left: 100 };
         var width = 620 - margin.left - margin.right;
         var height = 415 - margin.top - margin.bottom;
        


        var medianLinesVisible = false;
        
        var selectX = d3.select("#select-x");
        var selectY = d3.select("#select-y");
        var selectSize = d3.select("#select-size");
        
        var names = data.map(function(row) {
            return row[1];
        });
        
        // Populate the select dropdowns
        header.slice(3).forEach(function(metric) {
            selectX.append("option")
                .text(metric)
                .attr("value", metric);
            selectY.append("option")
                .text(metric)
                .attr("value", metric);
            selectSize.append("option")
                .text(metric)
                .attr("value", metric);
        });
        
        // Set default values for the selectors
        selectX.property("value", header[18]);
        selectY.property("value", header[20]);
        selectSize.property("value", header[3]);
        
        // Create the SVG container
        var svg = d3.select("#scatter-plot")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
    
        
        var xScale = d3.scaleLinear()
            .range([0, width]);
        var yScale = d3.scaleLinear()
            .range([height, 0]);
        var sizeScale = d3.scaleLinear()
            .range([5, 11]);
        
        var xAxis = d3.axisBottom(xScale).tickSize(0);
        var yAxis = d3.axisLeft(yScale).tickSize(0);
        
        // Add X axis
        var gXAxis = svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", "translate(0," + height + ")");
        
        // Add Y axis
        var gYAxis = svg.append("g")
            .attr("class", "y-axis");
        
        // Add axis labels
        var xLabel = svg.append("text")
            .attr("class", "x-label")
            .attr("text-anchor", "end")
            .attr("x", width)
            .attr("y", height + 35)
            .style("font-family", "Inter, sans-serif")
            .style("font-size", "14px");
        
        var yLabel = svg.append("text")
            .attr("class", "y-label")
            .attr("text-anchor", "end")
            .attr("transform", "rotate(-90)")
            .attr("y", -53)
            .attr("x", 0)
            .style("font-family", "Inter, sans-serif")
            .style("font-size", "14px");
        


        var clickedCircles = [];
        var filteredData = data;
        var filteredNames = names;
        var circles;
        
        updateChart = function() {
            d3.select("#scatter-plot")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);
                
            // Update axis positions based on new dimensions
            gXAxis.attr("transform", "translate(0," + height + ")");
            xLabel.attr("x", width)
                  .attr("y", height + 35);
            yLabel.attr("x", 0);
            
            // Check if dark mode is active
            const isDarkMode = document.body.classList.contains('dark-mode');
            
            // Get the selected league
            var selectedLeague = document.getElementById("select-league").value;
            
            // Get the selected age
            var selectedAge = document.getElementById("select-age").value;
            
            // Filter data based on selected league
                filteredData = data;

  
            
            // Update filtered names
            filteredNames = filteredData.map(function(d) {
                return d[1];
            });
            
            // Get the selected metrics
            xMetric = selectX.property("value");
            yMetric = selectY.property("value");
            sizeMetric = selectSize.property("value");
            
            // Update scales with consistent 10% padding on each side
            xScale.range([0, width])
      .domain(function() {
          // Get the raw extent
          const extent = d3.extent(filteredData, function(d) { 
              return +d[header.indexOf(xMetric)]; 
          });
          
          // Apply nice() to get rounded values
          const niceScale = d3.scaleLinear().domain(extent).nice();
          const niceExtent = niceScale.domain();
          
          // Calculate the original range and the nice range
          const originalRange = extent[1] - extent[0];
          const niceRange = niceExtent[1] - niceExtent[0];
          
          // Check if nice() added more than 10% padding
          if ((niceRange / originalRange) > 1.2) { // 1.2 represents original + 20% (10% on each side)
              // If so, use manual 10% padding instead
              const padding = originalRange * 0.1;
              return [extent[0] - padding, extent[1] + padding];
          } else {
              // Otherwise use the nice rounded values
              return niceExtent;
          }
      }());


                  yScale.range([height, 0])
      .domain(function() {
          // Get the raw extent
          const extent = d3.extent(filteredData, function(d) { 
              return +d[header.indexOf(yMetric)]; 
          });
          
          // Apply nice() to get rounded values
          const niceScale = d3.scaleLinear().domain(extent).nice();
          const niceExtent = niceScale.domain();
          
          // Calculate the original range and the nice range
          const originalRange = extent[1] - extent[0];
          const niceRange = niceExtent[1] - niceExtent[0];
          
          // Check if nice() added more than 10% padding
          if ((niceRange / originalRange) > 1.2) { // 1.2 represents original + 20% (10% on each side)
              // If so, use manual 10% padding instead
              const padding = originalRange * 0.1;
              return [extent[0] - padding, extent[1] + padding];
          } else {
              // Otherwise use the nice rounded values
              return niceExtent;
          }
      }());
        
                sizeScale.domain(d3.extent(filteredData, function(d) { 
                    return d[header.indexOf(sizeMetric)]; 
                }));
       
            
            // Update axes
            gXAxis.call(d3.axisBottom(xScale).tickSize(0));
            gYAxis.call(d3.axisLeft(yScale).tickSize(0));
            
            // Create metric key for translation
            const xMetricKey = "metrics." + xMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
            const yMetricKey = "metrics." + yMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
            
            // Set data-i18n attribute
            xLabel.attr("data-i18n", xMetricKey);
            yLabel.attr("data-i18n", yMetricKey);
            
            // Apply translations directly if available
            if (window.currentTranslations && window.currentTranslations.metrics) {
                const xTranslationKey = xMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
                const yTranslationKey = yMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
                
                const xTranslation = window.currentTranslations.metrics[xTranslationKey];
                const yTranslation = window.currentTranslations.metrics[yTranslationKey];
                
                xLabel.text(xTranslation || xMetric);
                yLabel.text(yTranslation || yMetric);
            } else {
                xLabel.text(xMetric);
                yLabel.text(yMetric);
            }

            // Remove existing circles and labels
            svg.selectAll("circle").remove();
            svg.selectAll(".team-label").remove();
            svg.selectAll(".xy-line").remove(); // Remove any existing diagonal reference line
            svg.selectAll(".xy-line-bg").remove(); // Remove line background
            svg.selectAll(".xy-line-label").remove(); // Remove line label
            svg.selectAll(".xy-line-label-bg").remove(); // Remove label background
            svg.selectAll(".performance-label").remove(); // Remove performance labels
            svg.selectAll("linearGradient#line-gradient").remove(); // Remove gradient definition
            svg.selectAll("marker#arrow-over, marker#arrow-under").remove(); // Remove arrow markers
            svg.selectAll(".xy-line-hover").remove(); // Remove hover detection element
            svg.selectAll(".median-line").remove(); // Always remove median lines before potentially redrawing them
            
            // Add diagonal reference line for xG vs Goals
            if ((xMetric === 'xG per 90' && yMetric === 'Goals per 90') || 
                (xMetric === 'Goals per 90' && yMetric === 'xG per 90') ||
                (xMetric === 'Non-penalty goals per 90' && yMetric === 'npxG per 90') ||
                (xMetric === 'npxG per 90' && yMetric === 'Non-penalty goals per 90') ||
                (xMetric === 'Assists per 90' && yMetric === 'xA per 90') ||
                (xMetric === 'xA per 90' && yMetric === 'Assists per 90') ||
                (xMetric === 'NPG+A per 90' && yMetric === 'npxG+xA per 90') ||
                (xMetric === 'npxG+xA per 90' && yMetric === 'NPG+A per 90') ||
                (xMetric === 'xG conceded per 90' && yMetric === 'Goals conceded per 90') ||
                (xMetric === 'Goals conceded per 90' && yMetric === 'xG conceded per 90') ||
                (xMetric === 'xG conceded' && yMetric === 'Goals conceded') ||
                (xMetric === 'Goals conceded' && yMetric === 'xG conceded')) 
                
                {
                
                // Variable to track hover timer for the diagonal line
                var diagonalLineHoverTimer = null;
                
                // Calculate the intersection points for the x=y line
                var minX = d3.min(filteredData, function(d) { return d[header.indexOf(xMetric)]; });
                var maxX = d3.max(filteredData, function(d) { return d[header.indexOf(xMetric)]; });
                var minY = d3.min(filteredData, function(d) { return d[header.indexOf(yMetric)]; });
                var maxY = d3.max(filteredData, function(d) { return d[header.indexOf(yMetric)]; });
                
                // Get the smaller max between the x and y axes
                var maxVal = Math.min(maxX, maxY);
                
                // Get the larger min between the x and y axes
                var minVal = Math.max(minX, minY);
                
                // Now draw the line only within these bounds
                svg.append("line")
                    .attr("class", "xy-line")
                    .attr("x1", xScale(minVal))
                    .attr("y1", yScale(minVal))
                    .attr("x2", xScale(maxVal))
                    .attr("y2", yScale(maxVal))
                    .style("stroke", "#2ecc71") // Simple green color
                    .style("stroke-width", "2")
                    .style("stroke-dasharray", "5,3");
                
                // Add invisible wider line for better hover detection
                svg.append("line")
                    .attr("class", "xy-line-hover")
                    .attr("x1", xScale(minVal))
                    .attr("y1", yScale(minVal))
                    .attr("x2", xScale(maxVal))
                    .attr("y2", yScale(maxVal))
                    .style("stroke", "transparent")
                    .style("stroke-width", "15")
                    .style("cursor", "help")
                    .on("mouseover", function() {
                        // Clear any existing timer
                        if (diagonalLineHoverTimer) {
                            clearTimeout(diagonalLineHoverTimer);
                        }
                        
                        // Capture the event coordinates
                        var eventX = d3.event.pageX;
                        var eventY = d3.event.pageY;
                        
                    })
              
            }
            
            // Add median lines if enabled
            if (medianLinesVisible) {
                // Calculate medians
                var xMedian = d3.median(filteredData, function(d) { 
                    return d[header.indexOf(xMetric)]; 
                });
                
                var yMedian = d3.median(filteredData, function(d) { 
                    return d[header.indexOf(yMetric)]; 
                });
                
                // Add X median line
                svg.append("line")
                    .attr("class", "median-line")
                    .attr("x1", xScale(xMedian))
                    .attr("y1", 0)
                    .attr("x2", xScale(xMedian))
                    .attr("y2", height)
                    .style("stroke", "rgba(0, 0, 0, 0.3)")
                    .style("stroke-dasharray", "4");
                
                // Add Y median line
                svg.append("line")
                    .attr("class", "median-line")
                    .attr("x1", 0)
                    .attr("y1", yScale(yMedian))
                    .attr("x2", width)
                    .attr("y2", yScale(yMedian))
                    .style("stroke", "rgba(0, 0, 0, 0.3)")
                    .style("stroke-dasharray", "4");
            }
            
            // Add circles
            circles = svg.selectAll("circle")
                .data(filteredData)
                .enter()
                .append("circle")
                .attr("cx", function(d) { return xScale(d[header.indexOf(xMetric)]); })
                .attr("cy", function(d) { return yScale(d[header.indexOf(yMetric)]); })
                .attr("r", function(d) { 
             
                    const value = d[header.indexOf(sizeMetric)];
                    return value !== undefined ? sizeScale(value) : 8;
                })
                .style("fill", function(d) {
                    // Check if this circle is in the clicked circles array
                    if (clickedCircles.includes(d[1])) {
                        return getLeagueColor(d[2]);
                    }
                    return "rgba(70, 130, 180, 0.7)";
                })
                .style("stroke", function(d) {
                    return clickedCircles.includes(d[1]) ? "#000" : "none";
                })
                .style("stroke-width", function(d) {
                    return clickedCircles.includes(d[1]) ? 2 : 0;
                })
            
                
            // Add labels for clicked teams
            clickedCircles.forEach(function(teamName) {
                var teamData = filteredData.find(function(d) {
                    return d[1] === teamName;
                });
                
                if (teamData) {
                    addTeamLabel(teamData, false);
                }
            });

            
    
                const playerData = filteredData.find(d => d[1] === "[PLAYER_NAME]");
        
                        svg.selectAll("circle").filter(function(d) {
                            return d[1] === "[PLAYER_NAME]";
                        })
                        .style("fill", function(d) {
                            return getLeagueColor(d[2]);
                        })
                        .style("stroke", "#000")
                        .style("stroke-width", 2)
                        .style("cursor", "default") // Set cursor to default after click
                        .each(function() {
                            // Bring Tielemans circle to front
                            this.parentNode.appendChild(this);
                        });
                        
                        // Add team label
                        addTeamLabel(playerData, false);
          
                    
                
                
                // Set flag to true so we don't try to click Bruno again
                initialClickPerformed = true;
            
        }
        
        
        
        // Function to remove special characters and diacritics for better search matching
        function removeSpecialCharsAndDiacritics(str) {
            if (!str) return '';
            return str.normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
                .replace(/Ø/g, 'O')
                .replace(/ø/g, 'o');
        }
        
        // Add search functionality
        var searchBar = document.getElementById("search-bar");
        
        searchBar.addEventListener("input", function() {
            var searchTerm = searchBar.value.toLowerCase();
            
            if (searchTerm === '') {
                resetSearch();
                return;
            }
            
            // Normalize search term to handle special characters and diacritics
            var normalizedSearchTerm = removeSpecialCharsAndDiacritics(searchTerm);
            
            // Reset previous search styling
            svg.selectAll("circle").classed("search-match", false)
                .style("fill", function(d) {
                    // Restore original fill color
                    return clickedCircles.includes(d[1]) ? getLeagueColor(d[2]) : "rgba(70, 130, 180, 0.7)";
                })
                .style("stroke", function(d) {
                    return clickedCircles.includes(d[1]) ? "#000" : "none";
                })
                .style("stroke-width", function(d) {
                    return clickedCircles.includes(d[1]) ? 2 : 0;
                })
                .style("filter", "none")
                .each(function() {
                    // Reset any inline styles that might interfere with our animation
                    d3.select(this).style("r", null);
                });
            
            svg.selectAll(".team-label")
                .classed("search-match", false)
                .classed("search-dimmed", false);
            
            // Find matching teams
            var matchingTeams = [];
            
            // Apply new search styling
            svg.selectAll("circle").filter(function(d) {
                var teamName = d[1].toLowerCase();
                var normalizedTeamName = removeSpecialCharsAndDiacritics(teamName);
                
                // Check both original and normalized versions for better matching
                var isMatch = teamName.includes(searchTerm) || normalizedTeamName.includes(normalizedSearchTerm);
                
                if (isMatch) {
                    matchingTeams.push(d[1]);
                }
                
                return isMatch;
            })
            .classed("search-match", true)
            .each(function() {
                // Bring matching circles to front
                this.parentNode.appendChild(this);
            });
            
            // If we have matches, dim non-matching labels
            if (matchingTeams.length > 0) {
                // First dim all labels
                svg.selectAll(".team-label").classed("search-dimmed", true);
                
                // Then highlight matching labels
                svg.selectAll(".team-label").filter(function() {
                    var labelText = d3.select(this).text();
                    return matchingTeams.includes(labelText);
                })
                .classed("search-match", true)
                .classed("search-dimmed", false)
                .each(function() {
                    // Bring matching labels to front
                    this.parentNode.appendChild(this);
                });
                
                // Add labels for matching teams that don't have labels yet
                matchingTeams.forEach(function(teamName) {
                    // Check if this team already has a label
                    var labelClass = "team-label-" + teamName.toLowerCase()
                .replace(/[^a-z0-9]/g, '-') // Replace any non-alphanumeric character with a hyphen
                .replace(/-+/g, '-')        // Replace multiple consecutive hyphens with a single one
                .replace(/^-|-$/g, '');     // Remove leading and trailing hyphens
            

                    if (svg.select("." + labelClass).size() === 0) {
                        // Find the team data
                        var teamData = filteredData.find(function(d) {
                            return d[1] === teamName;
                        });
                        
                        if (teamData) {
                            // Add the label with isSearchMatch=true to bypass collision detection
                            addTeamLabel(teamData, true);
                            // Apply search match styling (now done inside addTeamLabel)
                        }
                    }
                });
            } 
        });
        
      
        
        updateChart();
        


        function addTeamLabel(d, isSearchMatch) {
            var x = xScale(d[header.indexOf(xMetric)]);
            var y = yScale(d[header.indexOf(yMetric)]);
            
            // Create a unique class name for this team's label
            var teamClass = "team-label-" + d[1].toLowerCase()
                .replace(/[^a-z0-9]/g, '-') // Replace any non-alphanumeric character with a hyphen
                .replace(/-+/g, '-')        // Replace multiple consecutive hyphens with a single one
                .replace(/^-|-$/g, '');     // Remove leading and trailing hyphens
            
            // Check if this label already exists (avoid duplicates)
            if (svg.select("." + teamClass).size() > 0) {
                return;
            }
            
            // Create the label temporarily to measure its width
            var tempLabel = svg.append("text")
                .attr("class", "temp-label")
                .text(d[1])
                .style("font-family", "Inter, sans-serif")
                .style("font-size", "12px")
                .style("opacity", 0);
            
            var labelWidth = tempLabel.node().getComputedTextLength();
            tempLabel.remove();
            
            // Get chart boundaries
            var chartWidth = width;
            var chartHeight = height;
            
            var labelX = x + 18;
            var labelY = y;
            var anchor = "start";
            
            if (labelX + labelWidth > chartWidth) {
                // Place to the left instead
                labelX = x - 14;
                anchor = "end";
            }
            
            var label = svg.append("text")
                .attr("class", "team-label " + teamClass)
                .attr("x", labelX)
                .attr("y", labelY)
                .attr("text-anchor", anchor)
                .attr("dominant-baseline", "middle")
                .text(d[1])
                .style("font-family", "Inter, sans-serif")
                .style("font-size", "12px")
                .style("font-weight", "500")
                .style("fill", "#333");
        }
    });
    
 </script>
 
 
 
 <script>
 

 const allData2 = [];
let isFirstFileProcessed2 = false;

const urls2 = [
'https://datamb.football/database/CURRENT/TOP72425/ST/ST.xlsx',

];

const fetchPromises2 = urls2.map(url => fetch(url).then(response => response.arrayBuffer()));

Promise.all(fetchPromises2)
    .then(responses => {
        responses.forEach((data, index) => {
            const url = urls2[index]; // Get the URL of the current file being processed
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            // Perform transformations
            // 1. Cut column C and paste it to the end
            const columnC = jsonData.map(row => row[2]);
            jsonData.forEach((row, index) => row.push(columnC[index]));
            jsonData.forEach(row => row.splice(2, 1));

            // 2. Delete specified columns
            const columnsToDelete = [27, 28, 29, 30, 40, 47, 48, 49, 55, 59, 61, 70, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 92, 105, 107, 123, 128];
            columnsToDelete.sort((a, b) => b - a); // Sort in descending order
            columnsToDelete.forEach(col => {
                jsonData.forEach(row => row.splice(col, 1));
            });

            // 3. Insert new columns and fill with appropriate values
            if (url === 'https://datamb.football/database/CURRENT/TOP72425/ST/ST.xlsx' && !isFirstFileProcessed2) {
                // Include header only for the first file ('gk4.xlsx')
                jsonData.forEach(row => row.unshift(null)); // Insert empty column at the beginning
                jsonData[0][0] = "ID"; // Set header for the new column
                isFirstFileProcessed2 = true; // Mark the first file as processed
            } else {
                // Exclude header for all other files
                jsonData.forEach(row => row.unshift(undefined)); // Insert undefined at the beginning
            }

            // Fill ID column
            for (let i = 1; i < jsonData.length; i++) {
                jsonData[i][0] = i;
            }

            // 4. Replace ", m" with " m" and ", %" with " %"
            jsonData.forEach(row => {
                for (let i = 0; i < row.length; i++) {
                    if (typeof row[i] === 'string') {
                        row[i] = row[i].replace(', m', ' m').replace(', %', ' %');
                    }
                }
            });

            // 5. Collect the transformed data (excluding header for non-first 'gk4.xlsx')
            allData2.push(...(url === 'https://datamb.football/database/CURRENT/TOP72425/ST/ST.xlsx' ? jsonData : jsonData.slice(1)));
        });

const leagues = {
 
  
"Primeira Liga": [
"Porto", "Benfica", "Sporting CP", "Sporting Braga", "Vitória Guimarães", "Gil Vicente", "Farense", "Moreirense", "Nacional", "Arouca", "Estoril", "Rio Ave", "Santa Clara", "Boavista", "Casa Pia AC", "Famalicão", "Estrela Amadora", "AVS", "AVS ",
],

"Ligue 1": [
"PSG", "Lille", "Nice", "Lens", "Nantes", "Reims", "Olympique Lyonnais", "Monaco", "Olympique Marseille", "Brest", "Saint-Étienne", "Montpellier", "Angers SCO", "Le Havre", "Rennes", "Auxerre", "Strasbourg", "Toulouse", 
],

"Premier League": [
"Manchester City", "Tottenham Hotspur", "Arsenal", "Manchester United", "Aston Villa", "Liverpool", "Southampton", "Everton", "Chelsea", "Brighton", "Newcastle United", "Wolverhampton Wanderers", "Fulham", "Crystal Palace", "Brentford", "Bournemouth", "West Ham United", "Leicester City", "Nottingham Forest", "Ipswich Town", "Wolverhampton",
],

"Bundesliga": [
"Borussia Dortmund", "Stuttgart", "Wolfsburg", "Bayer Leverkusen", "Borussia M'gladbach", "Augsburg", "Union Berlin", "Eintracht Frankfurt", "Bayern München", "Hoffenheim", "Mainz 05", "Werder Bremen", "RB Leipzig", "St. Pauli", "Holstein Kiel", "Freiburg", "Heidenheim", "Bochum", "Borussia Mgladbach",
],

"Eredivisie": [
"PSV", "Feyenoord", "Sparta Rotterdam", "Twente", "Utrecht", "Groningen", "PEC Zwolle", "Almere City", "NAC Breda", "NEC", "Fortuna Sittard", "Go Ahead Eagles", "Heerenveen", "Willem II", "Heracles", "AZ", "RKC Waalwijk", "Ajax",
],

"La Liga": [
"Valencia", "Atlético Madrid", "Barcelona", "Real Madrid", "Real Sociedad", "Real Betis", "Osasuna", "Deportivo Alavés", "Getafe", "Athletic Bilbao", "Girona", "Mallorca", "Villarreal", "Real Valladolid", "Rayo Vallecano", "Leganés", "Sevilla", "Las Palmas", "Celta de Vigo", "Espanyol",
],

"Serie A": [
"Milan", "Juventus", "Atalanta", "Lazio", "Napoli", "Roma", "Monza", "Internazionale", "Lecce", "Torino", "Parma", "Udinese", "Genoa", "Hellas Verona", "Bologna", "Fiorentina", "Cagliari", "Venezia", "Como", "Empoli", 
], 
  

};


function getTeamLeague(team) {
            for (const [league, teams] of Object.entries(leagues)) {
                if (teams.includes(team)) {
                    return league;
                }
            }
            return "Unknown League";
        }

        const outputLines = [];
let playerId = 1; // Initialize player ID counter

allData2.forEach((row, index) => {
    // Ensure row has at least 3 elements
    if (row.length >= 3) {
        const team = row[2];
        const league = getTeamLeague(team);
        row[0] = playerId++; // Update the first element with the incremented player ID
        row[2] = league; // Replace the third element with the league information
        outputLines.push(row.join(",")); // Join the modified parts back into a line
    } else {
        // Handle rows that don't have at least 3 elements as needed
        outputLines.push(row.join(","));
    }
});

const output_data = outputLines.join("\n");

// Concatenate the extra header row with the fetched CSV data
let csvData = output_data;



        // Replace all '\n' characters with actual new rows in the CSV
        csvData = csvData.split('\\n').join('\n');




var rows = csvData.trim().split('\n');
var header = rows[0].split(',');
var data = rows.slice(1).map(function(row) {
  return row.split(',').map(function(d, i) {
    if (i >= 3) { // Assuming columns 2 and onwards contain numeric values
      return parseFloat(d);
    } else {
      return d;
    }
  });
});
        
        var margin = { top: 0, right: 0, bottom: 0, left: 0 };
        var width = 1082 - margin.left - margin.right;
        var height = 770 - margin.top - margin.bottom;
        
        // Define league colors for clicked circles
        var leagueColors = {
            "Premier League": "rgb(255, 0, 0, 0.7)",         // 1
            "La Liga": "rgb(255, 223, 0, 0.7)",             // 2
            "Bundesliga": "rgb(85, 209, 73, 0.7)",          // 3
            "Serie A": "rgb(0, 191, 255, 0.7)",             // 4
            "Ligue 1": "rgb(153, 50, 204, 0.7)",            // 5
            "Eredivisie": "rgb(255, 140, 0, 0.7)",          // 6
            "Primeira Liga": "rgb(255, 20, 147, 0.7)",      // 7
        };
        

        // Function to get color based on league
        function getLeagueColor(league) {
            return leagueColors[league] || "rgba(255, 0, 0, 0.7)"; // Default to red if league not found
        }
        
        var margin = { top: 40, right: 80, bottom: 100, left: 100 };
         var width = 620 - margin.left - margin.right;
         var height = 415 - margin.top - margin.bottom;
        


        var medianLinesVisible = true;
        
        var selectX = d3.select("#select-x");
        var selectY = d3.select("#select-y");
        var selectSize = d3.select("#select-size");
        
        var names = data.map(function(row) {
            return row[1];
        });
        
        // Populate the select dropdowns
        header.slice(3).forEach(function(metric) {
            selectX.append("option")
                .text(metric)
                .attr("value", metric);
            selectY.append("option")
                .text(metric)
                .attr("value", metric);
            selectSize.append("option")
                .text(metric)
                .attr("value", metric);
        });
        
        // Set default values for the selectors
        selectX.property("value", header[22]);
        selectY.property("value", header[24]);
        selectSize.property("value", header[3]);
        
        // Create the SVG container
        var svg = d3.select("#scatter-plot-2")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
    
        
        var xScale = d3.scaleLinear()
            .range([0, width]);
        var yScale = d3.scaleLinear()
            .range([height, 0]);
        var sizeScale = d3.scaleLinear()
            .range([5, 11]);
        
        var xAxis = d3.axisBottom(xScale).tickSize(0);
        var yAxis = d3.axisLeft(yScale).tickSize(0);
        
        // Add X axis
        var gXAxis = svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", "translate(0," + height + ")");
        
        // Add Y axis
        var gYAxis = svg.append("g")
            .attr("class", "y-axis");
        
        // Add axis labels
        var xLabel = svg.append("text")
            .attr("class", "x-label")
            .attr("text-anchor", "end")
            .attr("x", width)
            .attr("y", height + 35)
            .style("font-family", "Inter, sans-serif")
            .style("font-size", "14px");
        
        var yLabel = svg.append("text")
            .attr("class", "y-label")
            .attr("text-anchor", "end")
            .attr("transform", "rotate(-90)")
            .attr("y", -53)
            .attr("x", 0)
            .style("font-family", "Inter, sans-serif")
            .style("font-size", "14px");
        


        var clickedCircles = [];
        var filteredData2 = data;
        var filteredNames = names;
        var circles;
        
        updateChart = function() {
            d3.select("#scatter-plot-2")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);
                
            // Update axis positions based on new dimensions
            gXAxis.attr("transform", "translate(0," + height + ")");
            xLabel.attr("x", width)
                  .attr("y", height + 35);
            yLabel.attr("x", 0);
            
            // Check if dark mode is active
            const isDarkMode = document.body.classList.contains('dark-mode');
            
            // Get the selected league
            var selectedLeague = document.getElementById("select-league").value;
            
            // Get the selected age
            var selectedAge = document.getElementById("select-age").value;
            
            // Filter data based on selected league
                filteredData2 = data;

  
            
            // Update filtered names
            filteredNames = filteredData2.map(function(d) {
                return d[1];
            });
            
            // Get the selected metrics
            xMetric = selectX.property("value");
            yMetric = selectY.property("value");
            sizeMetric = selectSize.property("value");
            
            // Update scales with consistent 10% padding on each side
            xScale.range([0, width])
      .domain(function() {
          // Get the raw extent
          const extent = d3.extent(filteredData2, function(d) { 
              return +d[header.indexOf(xMetric)]; 
          });
          
          // Apply nice() to get rounded values
          const niceScale = d3.scaleLinear().domain(extent).nice();
          const niceExtent = niceScale.domain();
          
          // Calculate the original range and the nice range
          const originalRange = extent[1] - extent[0];
          const niceRange = niceExtent[1] - niceExtent[0];
          
          // Check if nice() added more than 10% padding
          if ((niceRange / originalRange) > 1.2) { // 1.2 represents original + 20% (10% on each side)
              // If so, use manual 10% padding instead
              const padding = originalRange * 0.1;
              return [extent[0] - padding, extent[1] + padding];
          } else {
              // Otherwise use the nice rounded values
              return niceExtent;
          }
      }());


                  yScale.range([height, 0])
      .domain(function() {
          // Get the raw extent
          const extent = d3.extent(filteredData2, function(d) { 
              return +d[header.indexOf(yMetric)]; 
          });
          
          // Apply nice() to get rounded values
          const niceScale = d3.scaleLinear().domain(extent).nice();
          const niceExtent = niceScale.domain();
          
          // Calculate the original range and the nice range
          const originalRange = extent[1] - extent[0];
          const niceRange = niceExtent[1] - niceExtent[0];
          
          // Check if nice() added more than 10% padding
          if ((niceRange / originalRange) > 1.2) { // 1.2 represents original + 20% (10% on each side)
              // If so, use manual 10% padding instead
              const padding = originalRange * 0.1;
              return [extent[0] - padding, extent[1] + padding];
          } else {
              // Otherwise use the nice rounded values
              return niceExtent;
          }
      }());
        
                sizeScale.domain(d3.extent(filteredData2, function(d) { 
                    return d[header.indexOf(sizeMetric)]; 
                }));
       
            
            // Update axes
            gXAxis.call(d3.axisBottom(xScale).tickSize(0));
            gYAxis.call(d3.axisLeft(yScale).tickSize(0));
            
            // Create metric key for translation
            const xMetricKey = "metrics." + xMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
            const yMetricKey = "metrics." + yMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
            
            // Set data-i18n attribute
            xLabel.attr("data-i18n", xMetricKey);
            yLabel.attr("data-i18n", yMetricKey);
            
            // Apply translations directly if available
            if (window.currentTranslations && window.currentTranslations.metrics) {
                const xTranslationKey = xMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
                const yTranslationKey = yMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
                
                const xTranslation = window.currentTranslations.metrics[xTranslationKey];
                const yTranslation = window.currentTranslations.metrics[yTranslationKey];
                
                xLabel.text(xTranslation || xMetric);
                yLabel.text(yTranslation || yMetric);
            } else {
                xLabel.text(xMetric);
                yLabel.text(yMetric);
            }

            // Remove existing circles and labels
            svg.selectAll("circle").remove();
            svg.selectAll(".team-label").remove();
            svg.selectAll(".xy-line").remove(); // Remove any existing diagonal reference line
            svg.selectAll(".xy-line-bg").remove(); // Remove line background
            svg.selectAll(".xy-line-label").remove(); // Remove line label
            svg.selectAll(".xy-line-label-bg").remove(); // Remove label background
            svg.selectAll(".performance-label").remove(); // Remove performance labels
            svg.selectAll("linearGradient#line-gradient").remove(); // Remove gradient definition
            svg.selectAll("marker#arrow-over, marker#arrow-under").remove(); // Remove arrow markers
            svg.selectAll(".xy-line-hover").remove(); // Remove hover detection element
            svg.selectAll(".median-line").remove(); // Always remove median lines before potentially redrawing them
            
            // Add diagonal reference line for xG vs Goals
            if ((xMetric === 'xG per 90' && yMetric === 'Goals per 90') || 
                (xMetric === 'Goals per 90' && yMetric === 'xG per 90') ||
                (xMetric === 'Non-penalty goals per 90' && yMetric === 'npxG per 90') ||
                (xMetric === 'npxG per 90' && yMetric === 'Non-penalty goals per 90') ||
                (xMetric === 'Assists per 90' && yMetric === 'xA per 90') ||
                (xMetric === 'xA per 90' && yMetric === 'Assists per 90') ||
                (xMetric === 'NPG+A per 90' && yMetric === 'npxG+xA per 90') ||
                (xMetric === 'npxG+xA per 90' && yMetric === 'NPG+A per 90') ||
                (xMetric === 'xG conceded per 90' && yMetric === 'Goals conceded per 90') ||
                (xMetric === 'Goals conceded per 90' && yMetric === 'xG conceded per 90') ||
                (xMetric === 'xG conceded' && yMetric === 'Goals conceded') ||
                (xMetric === 'Goals conceded' && yMetric === 'xG conceded')) 
                
                {
                
                // Variable to track hover timer for the diagonal line
                var diagonalLineHoverTimer = null;
                
                // Calculate the intersection points for the x=y line
                var minX = d3.min(filteredData2, function(d) { return d[header.indexOf(xMetric)]; });
                var maxX = d3.max(filteredData2, function(d) { return d[header.indexOf(xMetric)]; });
                var minY = d3.min(filteredData2, function(d) { return d[header.indexOf(yMetric)]; });
                var maxY = d3.max(filteredData2, function(d) { return d[header.indexOf(yMetric)]; });
                
                // Get the smaller max between the x and y axes
                var maxVal = Math.min(maxX, maxY);
                
                // Get the larger min between the x and y axes
                var minVal = Math.max(minX, minY);
                
                // Now draw the line only within these bounds
                svg.append("line")
                    .attr("class", "xy-line")
                    .attr("x1", xScale(minVal))
                    .attr("y1", yScale(minVal))
                    .attr("x2", xScale(maxVal))
                    .attr("y2", yScale(maxVal))
                    .style("stroke", "#2ecc71") // Simple green color
                    .style("stroke-width", "2")
                    .style("stroke-dasharray", "5,3");
                
                // Add invisible wider line for better hover detection
                svg.append("line")
                    .attr("class", "xy-line-hover")
                    .attr("x1", xScale(minVal))
                    .attr("y1", yScale(minVal))
                    .attr("x2", xScale(maxVal))
                    .attr("y2", yScale(maxVal))
                    .style("stroke", "transparent")
                    .style("stroke-width", "15")
                    .style("cursor", "help")
                    .on("mouseover", function() {
                        // Clear any existing timer
                        if (diagonalLineHoverTimer) {
                            clearTimeout(diagonalLineHoverTimer);
                        }
                        
                        // Capture the event coordinates
                        var eventX = d3.event.pageX;
                        var eventY = d3.event.pageY;
                        
                    })
              
            }
            
            // Add median lines if enabled
            if (medianLinesVisible) {
                // Calculate medians
                var xMedian = d3.median(filteredData2, function(d) { 
                    return d[header.indexOf(xMetric)]; 
                });
                
                var yMedian = d3.median(filteredData2, function(d) { 
                    return d[header.indexOf(yMetric)]; 
                });
                
                // Add X median line
                svg.append("line")
                    .attr("class", "median-line")
                    .attr("x1", xScale(xMedian))
                    .attr("y1", 0)
                    .attr("x2", xScale(xMedian))
                    .attr("y2", height)
                    .style("stroke", "rgba(0, 0, 0, 0.3)")
                    .style("stroke-dasharray", "4");
                
                // Add Y median line
                svg.append("line")
                    .attr("class", "median-line")
                    .attr("x1", 0)
                    .attr("y1", yScale(yMedian))
                    .attr("x2", width)
                    .attr("y2", yScale(yMedian))
                    .style("stroke", "rgba(0, 0, 0, 0.3)")
                    .style("stroke-dasharray", "4");
            }
            
            // Add circles
            circles = svg.selectAll("circle")
                .data(filteredData2)
                .enter()
                .append("circle")
                .attr("cx", function(d) { return xScale(d[header.indexOf(xMetric)]); })
                .attr("cy", function(d) { return yScale(d[header.indexOf(yMetric)]); })
                .attr("r", function(d) { 
             
                    const value = d[header.indexOf(sizeMetric)];
                    return value !== undefined ? sizeScale(value) : 8;
                })
                .style("fill", function(d) {
                    // Check if this circle is in the clicked circles array
                    if (clickedCircles.includes(d[1])) {
                        return getLeagueColor(d[2]);
                    }
                    return "rgba(70, 130, 180, 0.7)";
                })
                .style("stroke", function(d) {
                    return clickedCircles.includes(d[1]) ? "#000" : "none";
                })
                .style("stroke-width", function(d) {
                    return clickedCircles.includes(d[1]) ? 2 : 0;
                })
            
                
            // Add labels for clicked teams
            clickedCircles.forEach(function(teamName) {
                var teamData = filteredData2.find(function(d) {
                    return d[1] === teamName;
                });
                
                if (teamData) {
                    addTeamLabel(teamData, false);
                }
            });

            
    
                const playerData = filteredData2.find(d => d[1] === "[PLAYER_NAME]");
        
                        svg.selectAll("circle").filter(function(d) {
                            return d[1] === "[PLAYER_NAME]";
                        })
                        .style("fill", function(d) {
                            return getLeagueColor(d[2]);
                        })
                        .style("stroke", "#000")
                        .style("stroke-width", 2)
                        .style("cursor", "default") // Set cursor to default after click
                        .each(function() {
                            // Bring Tielemans circle to front
                            this.parentNode.appendChild(this);
                        });
                        
                        // Add team label
                        addTeamLabel(playerData, false);
          
                    
                
                
                // Set flag to true so we don't try to click Bruno again
                initialClickPerformed = true;
            
        }
        
        
        
        // Function to remove special characters and diacritics for better search matching
        function removeSpecialCharsAndDiacritics(str) {
            if (!str) return '';
            return str.normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
                .replace(/Ø/g, 'O')
                .replace(/ø/g, 'o');
        }
        
        // Add search functionality
        var searchBar = document.getElementById("search-bar");
        
        searchBar.addEventListener("input", function() {
            var searchTerm = searchBar.value.toLowerCase();
            
            if (searchTerm === '') {
                resetSearch();
                return;
            }
            
            // Normalize search term to handle special characters and diacritics
            var normalizedSearchTerm = removeSpecialCharsAndDiacritics(searchTerm);
            
            // Reset previous search styling
            svg.selectAll("circle").classed("search-match", false)
                .style("fill", function(d) {
                    // Restore original fill color
                    return clickedCircles.includes(d[1]) ? getLeagueColor(d[2]) : "rgba(70, 130, 180, 0.7)";
                })
                .style("stroke", function(d) {
                    return clickedCircles.includes(d[1]) ? "#000" : "none";
                })
                .style("stroke-width", function(d) {
                    return clickedCircles.includes(d[1]) ? 2 : 0;
                })
                .style("filter", "none")
                .each(function() {
                    // Reset any inline styles that might interfere with our animation
                    d3.select(this).style("r", null);
                });
            
            svg.selectAll(".team-label")
                .classed("search-match", false)
                .classed("search-dimmed", false);
            
            // Find matching teams
            var matchingTeams = [];
            
            // Apply new search styling
            svg.selectAll("circle").filter(function(d) {
                var teamName = d[1].toLowerCase();
                var normalizedTeamName = removeSpecialCharsAndDiacritics(teamName);
                
                // Check both original and normalized versions for better matching
                var isMatch = teamName.includes(searchTerm) || normalizedTeamName.includes(normalizedSearchTerm);
                
                if (isMatch) {
                    matchingTeams.push(d[1]);
                }
                
                return isMatch;
            })
            .classed("search-match", true)
            .each(function() {
                // Bring matching circles to front
                this.parentNode.appendChild(this);
            });
            
            // If we have matches, dim non-matching labels
            if (matchingTeams.length > 0) {
                // First dim all labels
                svg.selectAll(".team-label").classed("search-dimmed", true);
                
                // Then highlight matching labels
                svg.selectAll(".team-label").filter(function() {
                    var labelText = d3.select(this).text();
                    return matchingTeams.includes(labelText);
                })
                .classed("search-match", true)
                .classed("search-dimmed", false)
                .each(function() {
                    // Bring matching labels to front
                    this.parentNode.appendChild(this);
                });
                
                // Add labels for matching teams that don't have labels yet
                matchingTeams.forEach(function(teamName) {
                    // Check if this team already has a label
                    var labelClass = "team-label-" + teamName.toLowerCase()
                .replace(/[^a-z0-9]/g, '-') // Replace any non-alphanumeric character with a hyphen
                .replace(/-+/g, '-')        // Replace multiple consecutive hyphens with a single one
                .replace(/^-|-$/g, '');     // Remove leading and trailing hyphens
            

                    if (svg.select("." + labelClass).size() === 0) {
                        // Find the team data
                        var teamData = filteredData2.find(function(d) {
                            return d[1] === teamName;
                        });
                        
                        if (teamData) {
                            // Add the label with isSearchMatch=true to bypass collision detection
                            addTeamLabel(teamData, true);
                            // Apply search match styling (now done inside addTeamLabel)
                        }
                    }
                });
            } 
        });
        
      
        
        updateChart();
        


        function addTeamLabel(d, isSearchMatch) {
            var x = xScale(d[header.indexOf(xMetric)]);
            var y = yScale(d[header.indexOf(yMetric)]);
            
            // Create a unique class name for this team's label
            var teamClass = "team-label-" + d[1].toLowerCase()
                .replace(/[^a-z0-9]/g, '-') // Replace any non-alphanumeric character with a hyphen
                .replace(/-+/g, '-')        // Replace multiple consecutive hyphens with a single one
                .replace(/^-|-$/g, '');     // Remove leading and trailing hyphens
            
            // Check if this label already exists (avoid duplicates)
            if (svg.select("." + teamClass).size() > 0) {
                return;
            }
            
            // Create the label temporarily to measure its width
            var tempLabel = svg.append("text")
                .attr("class", "temp-label")
                .text(d[1])
                .style("font-family", "Inter, sans-serif")
                .style("font-size", "12px")
                .style("opacity", 0);
            
            var labelWidth = tempLabel.node().getComputedTextLength();
            tempLabel.remove();
            
            // Get chart boundaries
            var chartWidth = width;
            var chartHeight = height;
            
            var labelX = x + 18;
            var labelY = y;
            var anchor = "start";
            
            if (labelX + labelWidth > chartWidth) {
                // Place to the left instead
                labelX = x - 14;
                anchor = "end";
            }
            
            var label = svg.append("text")
                .attr("class", "team-label " + teamClass)
                .attr("x", labelX)
                .attr("y", labelY)
                .attr("text-anchor", anchor)
                .attr("dominant-baseline", "middle")
                .text(d[1])
                .style("font-family", "Inter, sans-serif")
                .style("font-size", "12px")
                .style("font-weight", "500")
                .style("fill", "#333");
        }
    });
    
 </script>

<script>

    // Global translation helper function
    function getTranslation(key, defaultText) {
        // Split the key into parts (e.g., "tooltip.xg-line-title" -> ["tooltip", "xg-line-title"])
        const keys = key.split('.');
        
        // Try to find the translation in the current language
        try {
            let currentTranslations = window.currentTranslations || {};
            for (const k of keys) {
                if (currentTranslations && currentTranslations[k]) {
                    currentTranslations = currentTranslations[k];
                } else {
                    return defaultText;
                }
            }
            return currentTranslations;
        } catch (e) {
            return defaultText;
        }
    }
    
  function setLanguage(language) {
    localStorage.setItem('preferredLanguage', language);
    const url = new URL(window.location.href);
    if (language === 'en') {
      url.searchParams.delete('lang');
    } else {
      url.searchParams.set('lang', language);
    }
    window.history.pushState({}, '', url);
    applyLanguage(language);
  }
  
  function getPreferredLanguage() {
    // PRIORITY 1: Check URL parameter first
    const urlParams = new URLSearchParams(window.location.search);
    const langParam = urlParams.get('lang');
    if (langParam) {
      return langParam;
    }
    // PRIORITY 2: Check localStorage
    const storedLang = localStorage.getItem('preferredLanguage');
    if (storedLang) {
      return storedLang;
    }
    // PRIORITY 3: Use browser language
    return getBrowserLanguage() || 'en';
  }

  function getBrowserLanguage() {
    return navigator.language.slice(0, 2);
  }

  function applyLanguage(language) {
    if (language === 'en') {
      return;
    }

    console.log(language);
    
    fetch(`/profiles/${language}.json`)
      .then(response => {
        // Don't throw an error, just return null if response is not OK
        return response.ok ? response.json() : null;
      })
      .then(translations => {
        // Only proceed if translations exist
        if (translations) {
          document.querySelectorAll('[data-i18n]').forEach(element => {
            const keys = element.getAttribute('data-i18n').split('.');
            let value = translations;
            for (const key of keys) {
              if (value === undefined || value === null) break;
              value = value[key];
            }
            if (value) {
              // Check if this element has template information
              const namePosition = element.getAttribute('data-name-position');
              
              // Get current content which now has the actual player name
              let currentContent = '';
              if (element.tagName === 'META') {
                currentContent = element.getAttribute('content');
              } else {
                currentContent = element.textContent || element.innerHTML;
              }
              
              // Apply translation with player name handling
              if (namePosition) {
                let translatedContent = '';
                
                // Extract the actual player name from the current content
                let playerName = '';
                
                if (namePosition === 'prefix') {
                  const footballIndex = currentContent.indexOf('Football');
                  const seasonIndex = currentContent.indexOf('2024/25');
                  
                  // Find the earliest occurrence of either delimiter
                  let delimiterIndex = -1;
                  if (footballIndex > 0 && seasonIndex > 0) {
                    delimiterIndex = Math.min(footballIndex, seasonIndex);
                  } else if (footballIndex > 0) {
                    delimiterIndex = footballIndex;
                  } else if (seasonIndex > 0) {
                    delimiterIndex = seasonIndex;
                  }
                  
                  if (delimiterIndex > 0) {
                    // Extract everything before the delimiter
                    playerName = currentContent.substring(0, delimiterIndex).trim();
                  }
                  
                  // Apply translation with player name at beginning
                  translatedContent = playerName + ' ' + value;
                } 
                
                // Apply the modified translation
                if (element.tagName === 'META') {
                  element.setAttribute('content', translatedContent);
                } else if (value.includes('<')) {
                  element.innerHTML = translatedContent;
                } else {
                  element.textContent = translatedContent;
                }
              } 
              // Normal translation without player name
              else {
                if (element.tagName === 'META') {
                  element.setAttribute('content', value);
                } else if (value.includes('<')) {
                  element.innerHTML = value;
                } else {
                  element.textContent = value;
                }
              }
            }
          });
          // REMOVE FOR PAGES WITH NO METADATA
          document.querySelector('meta[name="language"]').setAttribute('content', language);
        }
      })
      .catch(() => {
        // Completely empty catch block to silently ignore any errors
      });
  }
  
  const preferredLanguage = getPreferredLanguage();
  applyLanguage(preferredLanguage);
  
  // BUTTON LANGUAGE SWITCHER REMOVE FOR PAGES WITH NO LANGUAGE SWITCHER
  document.addEventListener('DOMContentLoaded', function() {
    const languageButton = document.getElementById('languageButton');
    const languageDropdown = document.getElementById('languageDropdown');
    

    if (languageButton) {
      languageButton.addEventListener('click', function(e) {
        e.stopPropagation();
        languageDropdown.classList.toggle('show');
      });
    }
  
    document.querySelectorAll('.language-option').forEach(option => {
      option.addEventListener('click', function(e) {
        e.preventDefault();
        const lang = this.getAttribute('href').split('=')[1];
        setLanguage(lang);
        languageDropdown.classList.remove('show');
      });
    });
  
    document.addEventListener('click', function(event) {
      if (!event.target.closest('.language-switcher-container')) {
        if (languageDropdown) {
          languageDropdown.classList.remove('show');
        }
      }
    });
  });
</script>

<footer class="footer">   
  <div class="google-play-container">

  <a href='https://play.google.com/store/apps/details?id=com.datamb.datamb.webviewflutter&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'><img alt='Get it on Google Play' src='https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png'></a>
<a href='https://apps.apple.com/app/datamb/id6456224067?l=en-GB'><img alt='Download on the App Store' src='https://developer.apple.com/assets/elements/badges/download-on-the-app-store.svg'></a></div>
<div class="logo">
    <img src="https://i.imgur.com/UurMbGS.png" alt="[PLAYER_NAME] football stats and data visuals. 2024/25 [PLAYER_NAME] player data profile compared to top 7 league players. Radar comparison and plot charts" />
  </div>

  <p class="description">DataMB</p>
  <p class="info" data-i18n="footer.copyright">© All Rights Reserved</p>
  <hr class="divider" />
  <div class="sub-footer">
    <nav>
      <a class="terms data-i18n="footer.terms" target="_blank" href="https://datamb.football/privacy">Privacy</a>
      <a class="privacy data-i18n="footer.privacy" href="https://datamb.football/guide#contact">Contact</a>
      <a class="glossary data-i18n="footer.glossary" href="https://datamb.football/guide#aboutus">About</a>
    </nav>
    <nav>
      <a target="_blank" href="https://twitter.com/datamb_" class="twitter-link">
                <svg width="23" height="22" fill="#000000" xmlns="http://www.w3.org/2000/svg">
          <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
        </svg>
      </a>
    </nav>
  </div>
</footer>


</body>
</html>
